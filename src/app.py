# -*- coding: utf-8 -*-
# Строка выше (shebang) указывает интерпретатору Python, что данный файл использует кодировку UTF-8.
# UTF-8 — это стандарт кодирования символов, позволяющий корректно отображать символы различных языков, включая кириллицу.
# Это особенно важно для комментариев и строковых литералов на русском языке.
"""
Основной модуль Flask-приложения. Точка сборки и инициализации всех компонентов.

Этот файл является сердцем всего веб-приложения. Его главная задача — создать
и сконфигурировать экземпляр Flask-приложения, который затем будет использоваться
веб-сервером (например, Gunicorn или встроенным сервером Flask для разработки)
для обработки входящих HTTP-запросов.

Здесь происходит последовательная инициализация и подключение всех ключевых частей приложения:
- Импорт необходимых библиотек и модулей:
    - `Flask`: основной класс для создания веб-приложения.
    - `Config`: класс, содержащий конфигурационные параметры (секретный ключ, настройки БД и т.д.).
    - `database`: модуль, отвечающий за работу с базой данных (SQLAlchemy).
    - `Migrate`: расширение Flask-Migrate для управления миграциями схемы базы данных.
    - `models`: модуль, описывающий структуру данных приложения (таблицы БД).
    - `commands`: модуль, содержащий пользовательские команды для интерфейса командной строки (CLI).
    - `LoginManager`: расширение Flask-Login для управления аутентификацией пользователей.
    - `main_bp`, `auth_bp`: "чертежи" (Blueprints) для разделения маршрутов на логические группы.
- Создание объекта приложения Flask (`app = Flask(__name__)`).
- Загрузка конфигурации из объекта `Config` (например, `app.config.from_object(Config)`).
- Инициализация расширения SQLAlchemy для работы с базой данных (`init_db(app)`).
- Инициализация Flask-Migrate для управления версиями схемы базы данных (`Migrate(app, db)`).
- Инициализация Flask-Login для управления сессиями пользователей (`login_manager.init_app(app)`).
- Регистрация пользовательских команд CLI, доступных через команду `flask` (например, `app.cli.add_command(data_cli)`).
- Регистрация "чертежей" (Blueprints), которые определяют маршруты и связанные с ними функции-обработчики.
- Определение контекстных процессоров для добавления переменных в глобальный контекст шаблонов Jinja2.
- Настройка точки входа для запуска сервера разработки (хотя в данном файле это неявно, запуск происходит через `wsgi.py` или `flask run`).
"""

# Импортируем основной класс `Flask` из библиотеки `flask`.
# `Flask` — это микрофреймворк для создания веб-приложений на Python.
# "Микро" означает, что он предоставляет только базовые инструменты,
# оставляя разработчику свободу выбора дополнительных библиотек и подходов.
# Этот класс является фундаментом, на котором строится все приложение.
from flask import Flask

# Импортируем расширение `Flask-Migrate` для управления изменениями в схеме базы данных (миграциями).
# `Flask-Migrate` интегрирует инструмент Alembic с Flask, позволяя легко создавать
# и применять миграции для изменения структуры таблиц, добавления новых полей и т.д.,
# не теряя при этом существующие данные. Это критически важно для эволюции приложения.
from flask_migrate import Migrate

# Импортируем класс `Config` из локального модуля `.config`.
# Точка перед `config` означает, что импорт происходит из текущего пакета (директории `src`).
# Класс `Config` содержит все настройки приложения: секретный ключ для сессий,
# URI для подключения к базе данных, флаги режима отладки и другие параметры.
# Использование отдельного файла/класса для конфигурации — это хорошая практика,
# позволяющая легко изменять настройки для разных окружений (разработка, тестирование, продакшн).
from .config import Config

# Импортируем объект `db` (экземпляр SQLAlchemy) и функцию `init_db` из локального модуля `.database`.
# `db` представляет собой сессию базы данных и предоставляет интерфейс для взаимодействия с ней
# (создание таблиц, выполнение запросов и т.д.).
# `init_db` — это функция, которая связывает экземпляр `db` с созданным Flask-приложением.
from .database import db, init_db

# Импортируем модуль `models` из текущего пакета.
# Этот импорт необходим для того, чтобы SQLAlchemy и Flask-Migrate "узнали" о существовании
# классов-моделей (например, `User`, `Organization`), которые описывают структуру таблиц в базе данных.
# Без этого импорта миграции не смогут корректно создать или обновить таблицы.
# Обычно в `models/__init__.py` или напрямую в `models.py` определены все классы моделей.
from . import models

# Импортируем объект `data_cli` из локального модуля `.commands`.
# `data_cli` — это, как правило, экземпляр `click.Group` или аналогичный объект,
# который объединяет пользовательские команды для интерфейса командной строки (CLI).
# Эти команды позволяют выполнять различные административные или служебные задачи,
# например, загрузку начальных данных, очистку кэша и т.п., используя команду `flask <имя_команды>`.
from .commands import data_cli

# Импортируем "Blueprints" (чертежи) `main_bp` и `auth_bp` из локальных модулей `.routes` и `.auth_routes` соответственно.
# Blueprints — это механизм Flask для структурирования больших приложений. Они позволяют
# группировать маршруты, шаблоны и статические файлы, относящиеся к определенной части функционала.
# `main_bp`, вероятно, содержит основные маршруты приложения (главная страница, информационные страницы).
# `auth_bp` содержит маршруты, связанные с аутентификацией (вход, регистрация, выход).
from .routes import main_bp
from .auth_routes import auth_bp

# Импортируем класс `LoginManager` из расширения `flask_login`.
# `Flask-Login` предоставляет функционал для управления сессиями пользователей:
# вход, выход, запоминание пользователя, защита маршрутов от неавторизованного доступа.
# `LoginManager` — это основной класс этого расширения, который нужно инициализировать и настроить.
from flask_login import LoginManager

# Создаем глобальный экземпляр `LoginManager`.
# Этот объект будет использоваться для настройки процесса аутентификации во всем приложении.
# Он будет инициализирован для конкретного экземпляра приложения Flask внутри функции `create_app`.
login_manager = LoginManager()

# Указываем `Flask-Login`, какую функцию-обработчик (view function) использовать для страницы входа.
# Если неавторизованный пользователь попытается получить доступ к защищенной странице
# (помеченной декоратором `@login_required`), `Flask-Login` перенаправит его на `'auth.login'`.
# `'auth.login'` — это имя маршрута, где `auth` — это имя Blueprint'а (`auth_bp`),
# а `login` — имя функции-обработчика маршрута входа в этом Blueprint'е.
login_manager.login_view = 'auth.login'

# Устанавливаем сообщение, которое будет показано пользователю, когда его перенаправляют на страницу входа.
# Это сообщение обычно отображается как flash-сообщение.
login_manager.login_message = 'Пожалуйста, войдите в систему для доступа к этой странице.'
# Устанавливаем категорию для flash-сообщения. Это может использоваться в шаблонах
# для стилизации сообщения (например, 'info', 'warning', 'error').
login_manager.login_message_category = 'info'

# Декоратор `@login_manager.user_loader` регистрирует функцию, которая будет вызываться `Flask-Login`
# для загрузки пользователя из базы данных по его идентификатору, хранящемуся в сессии.
# Эта функция необходима для восстановления состояния пользователя между запросами.
@login_manager.user_loader
def load_user(user_id):
    """
    Функция для загрузки пользователя по его идентификатору (user_id).
    Flask-Login вызывает эту функцию при каждом запросе, если пользователь ранее вошел в систему.
    Она получает `user_id` (обычно первичный ключ пользователя в таблице `users`) из сессионного cookie
    и должна вернуть соответствующий объект пользователя или `None`, если пользователь не найден.

    Аргументы:
        user_id (str): Идентификатор пользователя, извлеченный из сессии. Flask-Login передает его как строку.

    Возвращает:
        User | None: Объект пользователя, если он найден в базе данных, иначе None.
    """
    # Импортируем модель `User` здесь, внутри функции, чтобы избежать циклических зависимостей.
    # Циклические зависимости могут возникнуть, если модуль `models` сам импортирует что-то из `app.py`
    # (например, `login_manager`, хотя это и не лучший дизайн).
    # Локальный импорт решает эту проблему.
    from .models import User
    # Используем метод `db.session.get(Model, primary_key)` для получения пользователя из базы данных.
    # Этот метод является предпочтительным способом загрузки объекта по его первичному ключу в SQLAlchemy 2.0+.
    # `int(user_id)` преобразует строковый идентификатор из сессии в целое число,
    # так как первичные ключи обычно являются числовыми.
    return db.session.get(User, int(user_id))

# Определение "фабрики приложений" (Application Factory).
# Это рекомендуемый способ создания экземпляров Flask-приложения.
def create_app(config_class=Config):
    """
    Эта функция-фабрика создает, конфигурирует и возвращает экземпляр приложения Flask.
    Использование фабрики имеет несколько преимуществ:
    1.  Позволяет создавать несколько экземпляров приложения с разными конфигурациями
        (например, одно для разработки, другое для тестирования, третье для продакшена).
    2.  Помогает избежать циклических импортов, так как экземпляр приложения создается
        внутри функции, и к нему можно обращаться только после его создания.
    3.  Упрощает тестирование, так как можно легко создать "чистый" экземпляр приложения для каждого теста.

    Аргументы:
        config_class (class, optional): Класс, содержащий конфигурационные параметры.
                                         По умолчанию используется `Config` из модуля `src.config`.

    Возвращает:
        Flask: Сконфигурированный и готовый к работе экземпляр приложения Flask.
    """
    # Создаем основной объект приложения Flask.
    # `__name__` — это специальная встроенная переменная Python, которая в данном контексте
    # будет равна имени текущего модуля (т.е. 'src.app', если файл app.py находится в пакете src).
    # Flask использует это значение для определения корневого пути приложения,
    # что важно для поиска шаблонов (в папке `templates`) и статических файлов (в папке `static`).
    app = Flask(__name__)

    # Загружаем конфигурацию в приложение из указанного объекта `config_class`.
    # `app.config` — это словарь-подобный объект, хранящий все настройки Flask.
    # Метод `from_object()` загружает атрибуты из `config_class` (например, `SECRET_KEY`, `SQLALCHEMY_DATABASE_URI`)
    # в `app.config`. Это позволяет централизованно управлять настройками.
    app.config.from_object(config_class)

    # Инициализируем расширение SQLAlchemy для работы с базой данных.
    # Функция `init_db(app)` (из модуля `src.database`) обычно выполняет `db.init_app(app)`.
    # Это связывает экземпляр `db` (SQLAlchemy) с нашим Flask-приложением `app`.
    # После этого шага можно использовать `db.session` для взаимодействия с базой данных
    # в контексте приложения.
    init_db(app)

    # Инициализируем и настраиваем систему миграций базы данных с помощью Flask-Migrate.
    # `Migrate(app, db)` создает экземпляр `Migrate`, связывая его с Flask-приложением `app`
    # и объектом SQLAlchemy `db`. Это позволяет использовать команды `flask db ...`
    # (например, `flask db init`, `flask db migrate`, `flask db upgrade`) для управления
    # версиями схемы базы данных.
    migrate = Migrate(app, db) # Переменная migrate здесь создается, но не используется далее в этой функции.
                               # Однако, сам факт создания объекта Migrate(app, db) регистрирует команды миграций.

    # Инициализируем систему управления аутентификацией пользователей Flask-Login.
    # `login_manager.init_app(app)` связывает ранее созданный глобальный экземпляр `login_manager`
    # с текущим Flask-приложением `app`. Это активирует функционал Flask-Login для данного приложения,
    # включая обработку сессий, защиту маршрутов и вызов `user_loader`.
    login_manager.init_app(app)

    # Добавляем пользовательские команды CLI в приложение.
    # `app.cli` — это объект, предоставляющий интерфейс для добавления команд,
    # которые можно будет выполнять через терминал с помощью `flask <имя_команды>`.
    # `data_cli` (импортированный из `src.commands`) — это группа команд (например, `click.Group`),
    # которая может содержать одну или несколько подкоманд для различных задач (например, `flask data load_regions`).
    app.cli.add_command(data_cli)

    # Регистрируем "чертежи" (Blueprints) в приложении.
    # `app.register_blueprint(main_bp)` подключает все маршруты, определенные в `main_bp` (из `src.routes`),
    # к основному приложению. Аналогично для `auth_bp`.
    # Blueprints помогают модульно организовать маршруты, шаблоны и статические файлы.
    app.register_blueprint(main_bp)
    # Маршруты, связанные с аутентификацией (вход, регистрация, выход), будут доступны
    # по префиксам, определенным внутри `auth_bp` (если они есть), или напрямую от корня.
    app.register_blueprint(auth_bp)

    # Пример регистрации дополнительного Blueprint'а, например, для административной панели.
    # Этот код закомментирован, но показывает, как можно было бы добавить раздел администрирования.
    # `url_prefix='/admin'` означает, что все маршруты из `admin_bp` будут доступны по URL,
    # начинающимся с `/admin` (например, `/admin/users`, `/admin/settings`).
    # from .admin_routes import admin_bp  # Предполагается, что есть файл admin_routes.py
    # app.register_blueprint(admin_bp, url_prefix='/admin')

    # Контекстный процессор — это функция, которая автоматически добавляет переменные
    # в контекст всех шаблонов Jinja2, используемых в приложении.
    # Декоратор `@app.context_processor` регистрирует следующую за ним функцию как контекстный процессор.
    @app.context_processor
    def inject_current_year():
        """
        Эта функция-контекстный процессор добавляет переменную `current_year`
        в контекст каждого шаблона. Это позволяет легко отображать текущий год,
        например, в футере сайта, без необходимости передавать его вручную
        в каждой функции-обработчике маршрута.

        Возвращает:
            dict: Словарь, ключи которого становятся переменными в шаблонах.
        """
        # Импортируем модуль `datetime` для получения текущей даты и времени.
        from datetime import datetime
        # `datetime.utcnow().year` получает текущий год по всемирному координированному времени (UTC).
        # Возвращаем словарь, где ключ 'current_year' будет доступен в шаблонах как `{{ current_year }}`.
        return dict(current_year=datetime.utcnow().year)

    # Возвращаем полностью сконфигурированный и готовый к работе экземпляр приложения Flask.
    # Этот объект `app` затем будет использоваться WSGI-сервером для обработки запросов.
    return app

# Блок `if __name__ == '__main__':` здесь больше не нужен и даже вреден
# при использовании паттерна "фабрика приложений" и запуске через WSGI-сервер (например, Gunicorn)
# или встроенные команды Flask (`flask run`).
# Запуск приложения обычно настраивается в отдельном файле (например, `wsgi.py` для Gunicorn)
# или используется команда `flask run`, которая автоматически ищет фабрику `create_app`
# или экземпляр `app` в модуле, указанном в переменной окружения `FLASK_APP`.
# Если бы здесь был `app.run()`, это бы мешало правильному развертыванию на продакшн-серверах.

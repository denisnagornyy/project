# -*- coding: utf-8 -*-
# Указание кодировки UTF-8 для корректной работы с русскими символами.
"""
Модуль определения форм WTForms для веб-приложения.

Этот модуль является центральным местом для определения всех форм,
используемых в приложении для сбора и валидации пользовательского ввода.
Формы создаются с использованием библиотеки Flask-WTF, которая является
интеграцией WTForms с Flask и предоставляет удобства, такие как защита от CSRF,
интеграция с шаблонизатором Jinja2 и упрощенная обработка данных формы.

Здесь определены следующие типы форм:
- Формы для аутентификации пользователей (`LoginForm`, `RegistrationForm`).
- Формы для фильтрации данных в реестре (`FilterRegistryForm`).
- Формы для операций CRUD (Create, Read, Update, Delete) над сущностями
  (например, `OrganizationForm`, `StudyFormForm`, `RegionForm`).

Каждая форма представляет собой класс, наследуемый от `FlaskForm`.
Поля формы определяются как атрибуты класса, используя различные типы полей
из WTForms (например, `StringField`, `PasswordField`, `SelectField`).
Валидаторы (например, `DataRequired`, `Email`, `Length`, `EqualTo`)
применяются к полям для проверки корректности введенных данных.
Также могут быть определены пользовательские методы валидации для более сложной логики.
"""

# Импортируем базовый класс `FlaskForm` из расширения `flask_wtf`.
# `FlaskForm` является основой для всех форм в приложении, использующем Flask-WTF.
# Он наследуется от `wtforms.Form` и добавляет интеграцию с Flask,
# включая автоматическую CSRF-защиту (если настроена) и удобную обработку данных из запроса.
# Формы необходимы для структурированного получения данных от пользователя через HTML-формы,
# их валидации на сервере и безопасной обработки.
from flask_wtf import FlaskForm

# Импортируем различные типы полей, предоставляемые библиотекой WTForms.
# Каждый тип поля соответствует определенному HTML-элементу ввода и имеет
# свои специфические атрибуты и поведение.
# - `StringField`: Простое однострочное текстовое поле (HTML `<input type="text">`).
#   Используется для ввода коротких текстовых данных, таких как имена, заголовки и т.д.
# - `PasswordField`: Поле для ввода пароля (HTML `<input type="password">`).
#   Отображает вводимые символы как точки или звездочки для скрытия пароля.
# - `BooleanField`: Чекбокс (HTML `<input type="checkbox">`).
#   Представляет булево значение (истина/ложь, да/нет).
# - `SubmitField`: Кнопка отправки формы (HTML `<input type="submit">`).
#   Используется для инициации отправки данных формы на сервер.
# - `SelectField`: Выпадающий список (HTML `<select>`).
#   Позволяет пользователю выбрать одно или несколько значений из предопределенного списка.
#   Список вариантов (`choices`) обычно задается при создании поля или динамически.
# - `TextAreaField`: Многострочное текстовое поле (HTML `<textarea>`).
#   Используется для ввода длинных текстов, таких как описания, комментарии.
from wtforms import StringField, PasswordField, BooleanField, SubmitField, SelectField, TextAreaField

# Импортируем стандартные валидаторы из `wtforms.validators`.
# Валидаторы — это функции или классы, которые проверяют данные, введенные в поле формы,
# на соответствие определенным правилам. Если данные не проходят валидацию,
# форма считается невалидной, и пользователю обычно отображаются сообщения об ошибках.
# - `DataRequired`: Проверяет, что поле не пустое (т.е. данные были предоставлены).
#   Часто используется для обязательных полей. Эквивалентно `InputRequired` для большинства полей.
# - `Email`: Проверяет, что введенная строка соответствует формату email-адреса.
# - `EqualTo`: Проверяет, что значение текущего поля совпадает со значением другого указанного поля.
#   Часто используется для полей подтверждения пароля.
# - `ValidationError`: Специальный класс исключения, который нужно вызывать в пользовательских
#   валидаторах, чтобы сообщить об ошибке валидации. Сообщение об ошибке передается
#   в конструктор этого исключения.
# - `Optional`: Позволяет полю быть пустым. Если данные не предоставлены,
#   последующие валидаторы в цепочке для этого поля не будут выполняться.
#   Полезно для необязательных полей, которые, если заполнены, должны соответствовать другим правилам.
# - `Length`: Проверяет, что длина введенной строки находится в заданных пределах (min и/или max).
from wtforms.validators import DataRequired, Email, EqualTo, ValidationError, Optional, Length

# Импортируем модели данных (`User`, `Region`, `EducationalOrganization`) из локального модуля `.models`.
# Модели необходимы в формах для выполнения проверок, связанных с базой данных,
# например, для проверки уникальности имени пользователя или email при регистрации,
# или для динамического формирования списков выбора (хотя это чаще делается в маршрутах).
# Точка перед `models` означает относительный импорт из текущего пакета.
from .models import User, Region, EducationalOrganization # StudyForm также используется ниже, добавим его позже, если потребуется явно.

# Импортируем объект `db` (экземпляр SQLAlchemy) из локального модуля `.database`.
# Объект `db` необходим для выполнения запросов к базе данных внутри пользовательских
# методов валидации (например, для проверки, существует ли уже пользователь с таким email).
from .database import db

class FilterRegistryForm(FlaskForm):
    """
    Форма для фильтрации записей в реестре образовательных организаций.

    Эта форма позволяет пользователю задать критерии для отбора организаций,
    отображаемых на странице реестра. Включает поля для выбора региона,
    укрупненной группы специальностей (УГСН) и конкретной специальности.
    Все поля являются необязательными, что позволяет пользователю применять
    фильтры гибко.
    """

    # Поле для выбора региона. Тип `SelectField` (выпадающий список).
    # `label='Регион'` — текст, отображаемый рядом с полем.
    # `coerce=int` — функция, которая будет применена к выбранному значению перед валидацией
    #   и сохранением. В данном случае, значение из выпадающего списка (которое обычно является строкой)
    #   будет преобразовано в целое число (предполагается, что значениями являются ID регионов).
    # `validators=[Optional()]` — валидатор `Optional` означает, что это поле не является обязательным.
    #   Если пользователь ничего не выберет, это не будет считаться ошибкой.
    # `default=0` — значение по умолчанию для этого поля. Предполагается, что `0` соответствует
    #   опции "Все регионы" или аналогичной, которая будет добавлена в `choices`.
    region = SelectField('Регион', coerce=int, validators=[Optional()], default=0)

    # Поле для выбора укрупненной группы специальностей (УГСН). Аналогично полю `region`.
    specialty_group = SelectField('Укрупненная группа', coerce=int, validators=[Optional()], default=0)

    # Поле для выбора конкретной специальности. Аналогично полю `region`.
    # В более сложных реализациях список доступных специальностей (`choices`) может динамически
    # обновляться на стороне клиента (с помощью JavaScript) в зависимости от выбранной УГСН,
    # или же форма может перезагружаться для обновления списка.
    specialty = SelectField('Специальность', coerce=int, validators=[Optional()], default=0)

    # Кнопка отправки формы. Тип `SubmitField`.
    # `label='Применить фильтры'` — текст на кнопке.
    submit = SubmitField('Применить фильтры')

    def __init__(self, *args, **kwargs):
        """
        Конструктор формы `FilterRegistryForm`.

        Вызывает конструктор родительского класса `FlaskForm` и затем модифицирует
        списки `choices` для полей `SelectField`, добавляя в начало каждого списка
        опцию "Все ..." (например, "Все регионы"). Это позволяет пользователю
        легко сбросить соответствующий фильтр.

        Параметры:
            *args: Позиционные аргументы, передаваемые в конструктор родительского класса.
            **kwargs: Именованные аргументы, передаваемые в конструктор родительского класса.
                      Сюда могут входить, например, `request.form` для заполнения формы данными.
        """
        # Вызов конструктора родительского класса `FlaskForm`.
        # Это необходимо для правильной инициализации формы, включая обработку CSRF-токена,
        # загрузку данных из запроса (если они есть) и т.д.
        super(FilterRegistryForm, self).__init__(*args, **kwargs)

        # Динамическое добавление опции "Все ..." в начало списков выбора.
        # `self.region.choices` — это список кортежей `(value, label)`, представляющих опции
        # выпадающего списка. Этот список обычно заполняется в коде маршрута (view function)
        # перед передачей формы в шаблон.
        # Проверяем, что список `choices` не пуст и что первая опция не является уже "Все регионы" (с value=0).
        if self.region.choices and self.region.choices[0][0] != 0:
            # `insert(0, (0, 'Все регионы'))` добавляет новый кортеж в начало списка.
            self.region.choices.insert(0, (0, 'Все регионы'))

        # Аналогично для поля "Укрупненная группа".
        if self.specialty_group.choices and self.specialty_group.choices[0][0] != 0:
            self.specialty_group.choices.insert(0, (0, 'Все группы'))

        # Аналогично для поля "Специальность".
        if self.specialty.choices and self.specialty.choices[0][0] != 0:
            self.specialty.choices.insert(0, (0, 'Все специальности'))


# --- Формы для аутентификации ---
# Этот раздел содержит формы, используемые для процесса входа и регистрации пользователей.

class LoginForm(FlaskForm):
    """
    Форма для входа (аутентификации) пользователя в систему.

    Содержит поля для ввода имени пользователя (или email) и пароля,
    а также опциональный чекбокс "Запомнить меня".
    """
    # Поле для ввода имени пользователя или адреса электронной почты. Тип `StringField`.
    # `label='Имя пользователя или Email'` — текст метки поля.
    # `validators=[DataRequired(message="Это поле обязательно.")]` — список валидаторов.
    #   - `DataRequired`: Указывает, что это поле должно быть заполнено.
    #     `message="Это поле обязательно."` — текст сообщения об ошибке, если поле пустое.
    username_or_email = StringField('Имя пользователя или Email',
                                    validators=[DataRequired(message="Это поле обязательно.")])

    # Поле для ввода пароля. Тип `PasswordField`.
    # `label='Пароль'` — текст метки поля.
    # `validators=[DataRequired(message="Это поле обязательно.")]` — поле обязательно для заполнения.
    password = PasswordField('Пароль',
                             validators=[DataRequired(message="Это поле обязательно.")])

    # Чекбокс "Запомнить меня". Тип `BooleanField`.
    # `label='Запомнить меня'` — текст метки поля.
    # Если пользователь установит этот флажок, его сессия может сохраняться дольше
    # (например, с использованием постоянных cookie), в зависимости от настроек Flask-Login.
    remember_me = BooleanField('Запомнить меня')

    # Кнопка отправки формы. Тип `SubmitField`.
    # `label='Войти'` — текст на кнопке.
    submit = SubmitField('Войти')


class RegistrationForm(FlaskForm):
    """
    Форма для регистрации нового пользователя в системе.

    Содержит поля для ввода имени пользователя, email, пароля и подтверждения пароля.
    Включает валидаторы для проверки обязательности полей, формата email,
    длины имени пользователя и пароля, а также совпадения паролей.
    Также содержит пользовательские валидаторы для проверки уникальности
    имени пользователя и email в базе данных.
    """
    # Поле для ввода желаемого имени пользователя. Тип `StringField`.
    # `label='Имя пользователя'` — текст метки.
    # `validators=[...]` — список валидаторов:
    #   - `DataRequired(message="Это поле обязательно.")`: Поле не может быть пустым.
    #   - `Length(min=3, max=64, message="...")`: Длина имени пользователя должна быть
    #     в диапазоне от 3 до 64 символов. Сообщение об ошибке настраивается.
    username = StringField('Имя пользователя',
                           validators=[DataRequired(message="Это поле обязательно."),
                                       Length(min=3, max=64, message="Имя пользователя должно быть от 3 до 64 символов.")])

    # Поле для ввода адреса электронной почты. Тип `StringField`.
    # `label='Email'` — текст метки.
    # `validators=[...]` — список валидаторов:
    #   - `DataRequired(message="Это поле обязательно.")`: Поле не может быть пустым.
    #   - `Email(message="Некорректный формат Email.")`: Проверяет, что введенное значение
    #     похоже на корректный email-адрес.
    email = StringField('Email',
                        validators=[DataRequired(message="Это поле обязательно."),
                                    Email(message="Некорректный формат Email.")])

    # Поле для ввода пароля. Тип `PasswordField`.
    # `label='Пароль'` — текст метки.
    # `validators=[...]` — список валидаторов:
    #   - `DataRequired(message="Это поле обязательно.")`: Поле не может быть пустым.
    #   - `Length(min=6, message="...")`: Пароль должен содержать не менее 6 символов.
    password = PasswordField('Пароль',
                             validators=[DataRequired(message="Это поле обязательно."),
                                         Length(min=6, message="Пароль должен быть не менее 6 символов.")])

    # Поле для подтверждения пароля. Тип `PasswordField`.
    # `label='Повторите пароль'` — текст метки.
    # `validators=[...]` — список валидаторов:
    #   - `DataRequired(message="Это поле обязательно.")`: Поле не может быть пустым.
    #   - `EqualTo('password', message='Пароли должны совпадать.')`: Проверяет, что значение
    #     этого поля (`password2`) совпадает со значением поля `password`.
    #     Если не совпадают, отображается указанное сообщение об ошибке.
    password2 = PasswordField(
        'Повторите пароль', validators=[DataRequired(message="Это поле обязательно."),
                                     EqualTo('password', message='Пароли должны совпадать.')])

    # Кнопка отправки формы. Тип `SubmitField`.
    # `label='Зарегистрироваться'` — текст на кнопке.
    submit = SubmitField('Зарегистрироваться')

    # Пользовательские (inline) валидаторы.
    # WTForms автоматически вызывает методы с именами `validate_<имя_поля>`
    # после выполнения стандартных валидаторов для соответствующего поля.
    # Эти методы должны принимать два аргумента: `self` (экземпляр формы)
    # и объект поля, которое валидируется (здесь `username` и `email`).
    # Если валидация не проходит, метод должен вызвать `ValidationError` с сообщением об ошибке.

    def validate_username(self, username_field):
        """
        Пользовательский валидатор для поля `username`.
        Проверяет, не занято ли введенное имя пользователя другим пользователем в базе данных.

        Параметры:
            username_field (wtforms.fields.StringField): Объект поля `username` из формы.
                                                        Его значение доступно через `username_field.data`.
        """
        # Выполняем запрос к базе данных для поиска пользователя с таким же именем.
        # `db.session.scalar(...)` используется для получения одного значения или None.
        # `db.select(User).filter_by(username=username_field.data)` создает запрос
        # для выбора пользователя, у которого поле `username` равно введенному значению.
        user = db.session.scalar(db.select(User).filter_by(username=username_field.data))
        # Если пользователь с таким именем найден (`user is not None`),
        # значит, имя занято. Вызываем `ValidationError`.
        if user is not None:
            raise ValidationError('Это имя пользователя уже занято. Пожалуйста, выберите другое.')

    def validate_email(self, email_field):
        """
        Пользовательский валидатор для поля `email`.
        Проверяет, не зарегистрирован ли уже пользователь с таким email-адресом.

        Параметры:
            email_field (wtforms.fields.StringField): Объект поля `email` из формы.
                                                     Его значение доступно через `email_field.data`.
        """
        # Аналогично `validate_username`, ищем пользователя по email.
        user = db.session.scalar(db.select(User).filter_by(email=email_field.data))
        # Если пользователь с таким email найден, вызываем `ValidationError`.
        if user is not None:
            raise ValidationError('Этот email уже зарегистрирован. Пожалуйста, используйте другой.')


# --- Формы для CRUD операций ---
# Этот раздел содержит формы, предназначенные для создания, чтения, обновления и удаления (CRUD)
# различных сущностей в приложении, таких как образовательные организации, регионы и т.д.

class OrganizationForm(FlaskForm):
    """
    Форма для добавления или редактирования информации об образовательной организации.

    Эта форма используется для сбора данных, необходимых для создания новой записи
    об образовательной организации или для обновления существующей.
    Включает поля для наименования, ОГРН, ИНН, адреса и региона.
    """
    # Поле для полного наименования организации. Тип `StringField`.
    # `validators=[DataRequired()]` — поле обязательно для заполнения.
    # Сообщение по умолчанию для `DataRequired` — "This field is required."
    # Можно указать свое: `DataRequired(message="Полное наименование обязательно.")`
    full_name = StringField('Полное наименование', validators=[DataRequired(message="Полное наименование обязательно для заполнения.")])

    # Поле для краткого наименования организации. Тип `StringField`. Необязательное.
    short_name = StringField('Краткое наименование', validators=[Optional()])

    # Поле для ОГРН (Основной государственный регистрационный номер). Тип `StringField`.
    # `validators=[DataRequired(), Length(min=13, max=15)]`
    #   - `DataRequired()`: Обязательное поле.
    #   - `Length(min=13, max=15)`: Длина ОГРН должна быть 13 или 15 символов.
    #     (Примечание: ОГРНЮЛ - 13 цифр, ОГРНИП - 15 цифр. Для организаций обычно 13).
    #     Стоит уточнить, какой тип ОГРН ожидается, или сделать валидацию более гибкой.
    ogrn = StringField('ОГРН', validators=[DataRequired(message="ОГРН обязателен."),
                                          Length(min=13, max=15, message="ОГРН должен содержать 13 или 15 цифр.")])

    # Поле для ИНН (Идентификационный номер налогоплательщика). Тип `StringField`.
    # `validators=[Optional(), Length(min=10, max=12)]`
    #   - `Optional()`: Поле необязательное.
    #   - `Length(min=10, max=12)`: Если ИНН указан, его длина должна быть 10 (для юр. лиц)
    #     или 12 (для физ. лиц и ИП) символов.
    inn = StringField('ИНН', validators=[Optional(),
                                        Length(min=10, max=12, message="ИНН должен содержать 10 или 12 цифр.")])

    # Многострочное текстовое поле для адреса организации. Тип `TextAreaField`. Необязательное.
    address = TextAreaField('Адрес', validators=[Optional()])

    # Выпадающий список для выбора региона, к которому относится организация. Тип `SelectField`.
    # `coerce=int`: Преобразует выбранное значение (ID региона) в целое число.
    # `validators=[Optional()]`: Выбор региона необязателен.
    # Список `choices` для этого поля должен быть заполнен в коде маршрута.
    region = SelectField('Регион', coerce=int, validators=[Optional()])

    # Кнопка отправки формы.
    submit = SubmitField('Сохранить')

    def __init__(self, original_ogrn=None, *args, **kwargs):
        """
        Конструктор формы `OrganizationForm`.

        Инициализирует форму и сохраняет оригинальное значение ОГРН (`original_ogrn`),
        если оно передано. Это необходимо для корректной работы валидатора уникальности ОГРН
        при редактировании существующей организации (чтобы не возникало ошибки, если ОГРН не менялся).

        Параметры:
            original_ogrn (str, optional): Оригинальное значение ОГРН редактируемой организации.
                                           Передается, если форма используется для редактирования.
                                           По умолчанию `None` (для создания новой организации).
            *args, **kwargs: Стандартные аргументы для конструктора `FlaskForm`.
        """
        super(OrganizationForm, self).__init__(*args, **kwargs)
        # Сохраняем `original_ogrn` как атрибут экземпляра формы.
        self.original_ogrn = original_ogrn

        # Закомментированный код ниже показывает пример, как можно было бы заполнять
        # списки `choices` для полей `SelectField` (например, `region` или `parent`, если бы оно было)
        # прямо в конструкторе формы. Однако, более распространенной практикой является
        # заполнение `choices` в функции-обработчике маршрута (view function), так как
        # это дает больше гибкости и позволяет, например, кэшировать эти списки.
        #
        # Пример для поля 'region':
        # self.region.choices = [(r.id, r.name) for r in db.session.scalars(db.select(Region).order_by(Region.name)).all()]
        # self.region.choices.insert(0, (0, '--- Не выбрано ---')) # Добавление опции "не выбрано"
        #
        # Пример для гипотетического поля 'parent' (головная организация):
        # self.parent.choices = [(o.id, o.short_name or o.full_name) for o in db.session.scalars(db.select(EducationalOrganization).filter_by(parent_id=None).order_by(EducationalOrganization.short_name)).all()]
        # self.parent.choices.insert(0, (0, '--- Нет (Головная организация) ---'))

    def validate_ogrn(self, ogrn_field):
        """
        Пользовательский валидатор для поля `ogrn`.
        Проверяет уникальность ОГРН в базе данных.
        При редактировании организации, если ОГРН не изменился, проверка уникальности пропускается.

        Параметры:
            ogrn_field (wtforms.fields.StringField): Объект поля `ogrn`.
        """
        # Если `self.original_ogrn` установлен (т.е. форма используется для редактирования)
        # и текущее значение поля ОГРН (`ogrn_field.data`) совпадает с оригинальным,
        # то это означает, что ОГРН не менялся. В этом случае проверку уникальности проводить не нужно.
        if self.original_ogrn and self.original_ogrn == ogrn_field.data:
            return # Выходим из валидатора

        # Ищем организацию с таким же ОГРН в базе данных.
        organization = db.session.scalar(db.select(EducationalOrganization).filter_by(ogrn=ogrn_field.data))
        # Если организация найдена, значит, такой ОГРН уже существует. Вызываем `ValidationError`.
        if organization:
            raise ValidationError('Организация с таким ОГРН уже существует в базе данных.')

    def validate_inn(self, inn_field):
        """
        Пользовательский валидатор для поля `inn`.
        Проверяет уникальность ИНН в базе данных, если ИНН указан.
        Аналогично ОГРН, при редактировании можно было бы добавить проверку
        на изменение ИНН, если бы передавался `original_inn`.

        Параметры:
            inn_field (wtforms.fields.StringField): Объект поля `inn`.
        """
        # Если поле ИНН не заполнено (`inn_field.data` пустое), то проверку уникальности не проводим.
        # Это соответствует валидатору `Optional()`, который уже применен к полю.
        if not inn_field.data:
            return # Выходим из валидатора

        # Здесь можно было бы добавить логику для пропуска проверки, если ИНН не изменился при редактировании,
        # аналогично `validate_ogrn`, если бы мы передавали `self.original_inn` в конструктор.
        # Например:
        # if hasattr(self, 'original_inn') and self.original_inn and self.original_inn == inn_field.data:
        #     return

        # Ищем организацию с таким же ИНН в базе данных.
        organization = db.session.scalar(db.select(EducationalOrganization).filter_by(inn=inn_field.data))
        # Если организация найдена, вызываем `ValidationError`.
        if organization:
            raise ValidationError('Организация с таким ИНН уже существует в базе данных.')

# TODO: Добавить формы для редактирования программ, специальностей и т.д.
# Это напоминание разработчику о необходимости создать дополнительные формы
# для управления другими сущностями системы, такими как образовательные программы,
# специальности, учебные планы и прочее, если это предусмотрено функционалом.
# Каждая такая сущность, если ею можно управлять через веб-интерфейс,
# вероятно, потребует своей собственной WTForm.

# TODO: Добавить форму смены пароля
# Это еще одно напоминание о важной функции, которую следует реализовать:
# форма для смены пароля существующим пользователем. Такая форма обычно включает поля:
# - Старый пароль (для подтверждения личности).
# - Новый пароль.
# - Подтверждение нового пароля.
# Также потребуются соответствующие валидаторы и логика обработки в маршруте.

class StudyFormForm(FlaskForm): # "StudyFormForm" - имя может быть немного избыточным, возможно "StudyModeForm" или "LearningFormForm" было бы лучше.
    """
    Форма для добавления или редактирования формы обучения (например, "Очная", "Заочная").

    Содержит поле для названия формы обучения и кнопку сохранения.
    Включает валидатор для проверки уникальности названия.
    """
    # Поле для названия формы обучения. Тип `StringField`.
    # `validators=[DataRequired(), Length(max=100)]`
    #   - `DataRequired()`: Название обязательно для заполнения.
    #   - `Length(max=100)`: Максимальная длина названия — 100 символов.
    name = StringField('Название формы обучения', validators=[DataRequired(message="Название формы обучения обязательно."),
                                                            Length(max=100, message="Название не должно превышать 100 символов.")])
    # Кнопка отправки формы.
    submit = SubmitField('Сохранить')

    def __init__(self, original_name=None, *args, **kwargs):
        """
        Конструктор формы `StudyFormForm`.

        Сохраняет оригинальное название формы обучения для проверки уникальности при редактировании.

        Параметры:
            original_name (str, optional): Оригинальное название редактируемой формы обучения.
            *args, **kwargs: Стандартные аргументы для конструктора `FlaskForm`.
        """
        super(StudyFormForm, self).__init__(*args, **kwargs)
        self.original_name = original_name

    def validate_name(self, name_field):
        """
        Пользовательский валидатор для поля `name` (название формы обучения).
        Проверяет уникальность названия формы обучения в базе данных, игнорируя регистр символов.
        При редактировании, если название не изменилось (с учетом регистра), проверка пропускается.

        Параметры:
            name_field (wtforms.fields.StringField): Объект поля `name`.
        """
        # Импортируем модель StudyForm здесь, чтобы избежать возможных циклических импортов,
        # если бы этот файл импортировался в models.py до определения всех моделей.
        # Хотя в данном случае .models уже импортирован выше, это безопасная практика.
        from .models import StudyForm # Убедимся, что StudyForm есть в импортах в начале файла или здесь.

        # Ищем форму обучения с таким же названием в базе данных, приводя оба значения к нижнему регистру
        # для регистронезависимого сравнения. `db.func.lower()` используется для применения SQL-функции LOWER.
        form_entry = db.session.scalar(
            db.select(StudyForm).filter(db.func.lower(StudyForm.name) == name_field.data.lower())
        )

        # Проверяем, найдена ли запись (`form_entry is not None`).
        # И дополнительное условие для редактирования:
        # `(not self.original_name or name_field.data.lower() != self.original_name.lower())`
        # Это условие означает, что ошибка уникальности возникает, только если:
        #   1. Это новая запись (`self.original_name` отсутствует), И форма с таким именем уже есть.
        #   2. Это редактирование существующей записи (`self.original_name` есть), И введенное имя
        #      отличается от оригинального (с учетом регистра), И форма с таким новым именем уже есть.
        if form_entry and (not self.original_name or name_field.data.lower() != self.original_name.lower()):
            raise ValidationError('Форма обучения с таким названием уже существует.')

class RegionForm(FlaskForm):
    """
    Форма для добавления или редактирования региона.

    Содержит поле для названия региона и кнопку сохранения.
    Включает валидатор для проверки уникальности названия региона.
    """
    # Поле для названия региона. Тип `StringField`.
    # `validators=[DataRequired(), Length(max=200)]`
    #   - `DataRequired()`: Название обязательно для заполнения.
    #   - `Length(max=200)`: Максимальная длина названия — 200 символов.
    name = StringField('Название региона', validators=[DataRequired(message="Название региона обязательно."),
                                                     Length(max=200, message="Название не должно превышать 200 символов.")])
    # Кнопка отправки формы.
    submit = SubmitField('Сохранить')

    def __init__(self, original_name=None, *args, **kwargs):
        """
        Конструктор формы `RegionForm`.

        Сохраняет оригинальное название региона для проверки уникальности при редактировании.

        Параметры:
            original_name (str, optional): Оригинальное название редактируемого региона.
            *args, **kwargs: Стандартные аргументы для конструктора `FlaskForm`.
        """
        super(RegionForm, self).__init__(*args, **kwargs)
        self.original_name = original_name

    def validate_name(self, name_field):
        """
        Пользовательский валидатор для поля `name` (название региона).
        Проверяет уникальность названия региона в базе данных, игнорируя регистр.
        При редактировании, если название не изменилось (с учетом регистра), проверка пропускается.

        Параметры:
            name_field (wtforms.fields.StringField): Объект поля `name`.
        """
        # Ищем регион с таким же названием (регистронезависимо).
        region_entry = db.session.scalar(
            db.select(Region).filter(db.func.lower(Region.name) == name_field.data.lower())
        )
        # Логика проверки уникальности аналогична `StudyFormForm.validate_name`.
        if region_entry and (not self.original_name or name_field.data.lower() != self.original_name.lower()):
            raise ValidationError('Регион с таким названием уже существует.')

# -*- coding: utf-8 -*-
# Указание кодировки UTF-8 для корректной работы с русскими символами в комментариях и строках.
"""
Модуль определения маршрутов для аутентификации и авторизации пользователей (Blueprint 'auth').

Этот модуль инкапсулирует всю логику, связанную с управлением учетными записями пользователей:
- Регистрация новых пользователей.
- Вход существующих пользователей в систему (аутентификация).
- Выход пользователей из системы.
- Потенциально (в будущем) — восстановление пароля, смена пароля и другие связанные функции.

Используется механизм Flask Blueprints для модульной организации маршрутов.
Все маршруты, определенные в этом файле, будут иметь префикс '/auth' (например, '/auth/login', '/auth/register').
"""

# Импортируем необходимые компоненты из библиотеки Flask:
# - Blueprint: Класс для создания компонента приложения ("чертежа"). Позволяет группировать маршруты,
#   шаблоны и статические файлы, делая приложение более структурированным и масштабируемым.
#   Каждый Blueprint может иметь свой префикс URL и собственный набор шаблонов и статических файлов.
# - render_template: Функция для генерации HTML-ответа на основе Jinja2 шаблона.
#   Она принимает имя файла шаблона и переменные, которые будут доступны в этом шаблоне.
# - redirect: Функция для выполнения HTTP-перенаправления на другой URL.
# - url_for: Функция для генерации URL-адресов на основе имени функции-обработчика маршрута (view function)
#   или имени конечной точки (endpoint). Это предпочтительный способ создания URL, так как он
#   устойчив к изменениям в структуре маршрутов.
# - flash: Функция для отображения временных сообщений пользователю (flash messages).
#   Эти сообщения обычно отображаются на следующей странице после их установки и полезны
#   для информирования пользователя об успехе или неудаче операции (например, "Вы успешно вошли в систему").
# - request: Глобальный объект, представляющий текущий HTTP-запрос от клиента.
#   Содержит информацию о методе запроса (GET, POST), заголовках, данных формы, аргументах URL и т.д.
from flask import Blueprint, render_template, redirect, url_for, flash, request

# Импортируем компоненты из расширения Flask-Login для управления сессиями пользователей:
# - login_user: Функция для регистрации пользователя как вошедшего в систему.
#   Она устанавливает необходимые сессионные данные для идентификации пользователя в последующих запросах.
# - logout_user: Функция для завершения сессии текущего пользователя (выход из системы).
#   Удаляет сессионные данные, связанные с пользователем.
# - current_user: Прокси-объект, который представляет текущего аутентифицированного пользователя.
#   Если пользователь не вошел в систему, `current_user.is_authenticated` будет `False`.
#   Этот объект доступен в шаблонах и функциях-обработчиках.
# - login_required: Декоратор, который можно применять к функциям-обработчикам маршрутов
#   для ограничения доступа только аутентифицированным пользователям. Если неаутентифицированный
#   пользователь пытается получить доступ к такому маршруту, Flask-Login перенаправит его
#   на страницу входа (заданную в `login_manager.login_view`).
from flask_login import login_user, logout_user, current_user, login_required

# Импортируем функцию `urlparse` из стандартной библиотеки Python `urllib.parse`.
# Эта функция используется для разбора URL-строки на компоненты (схема, сетевое расположение, путь и т.д.).
# В данном контексте она важна для проверки безопасности URL-адреса перенаправления (`next_page`),
# чтобы предотвратить атаки типа "open redirect" (перенаправление на вредоносный внешний сайт).
from urllib.parse import urlparse

# Импортируем классы форм `LoginForm` и `RegistrationForm` из локального модуля `.forms`.
# Точка перед `forms` означает, что модуль `forms.py` находится в том же пакете (директории `src`).
# Эти классы, вероятно, унаследованы от `FlaskForm` (из WTForms) и определяют поля форм
# для входа и регистрации, а также правила их валидации.
from .forms import LoginForm, RegistrationForm

# Импортируем модель `User` из локального модуля `.models`.
# Модель `User` представляет таблицу пользователей в базе данных и определяет атрибуты пользователя
# (например, `id`, `username`, `email`, `password_hash`), а также методы для работы с паролями
# (например, `set_password`, `check_password`).
from .models import User

# Импортируем объект `db` (экземпляр SQLAlchemy) из локального модуля `.database`.
# Этот объект предоставляет интерфейс для взаимодействия с базой данных: создание сессий,
# выполнение запросов, управление транзакциями.
from .database import db

# Создаем экземпляр Blueprint с именем 'auth'.
# Первый аргумент 'auth' — это имя Blueprint'а. Оно используется для именования конечных точек (endpoints)
# и для генерации URL с помощью `url_for` (например, `url_for('auth.login')`).
# Второй аргумент `__name__` — это имя текущего модуля (`src.auth_routes`). Flask использует его
# для определения корневого пути Blueprint'а (например, для поиска шаблонов, если они специфичны для этого Blueprint'а).
# `url_prefix='/auth'` означает, что все URL-адреса, определенные в этом Blueprint'е,
# будут автоматически начинаться с префикса `/auth`. Например, маршрут `/login` станет `/auth/login`.
auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

# Определяем маршрут для страницы входа пользователя.
# Декоратор `@auth_bp.route('/login', methods=['GET', 'POST'])` связывает URL '/login' (с учетом префикса '/auth')
# с функцией `login()`.
# `methods=['GET', 'POST']` указывает, что этот маршрут может обрабатывать как GET-запросы (когда пользователь
# просто открывает страницу входа), так и POST-запросы (когда пользователь отправляет заполненную форму входа).
@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    """
    Функция-обработчик для страницы входа пользователя (/auth/login).

    Логика работы:
    1. Если пользователь уже аутентифицирован, он перенаправляется на главную страницу реестра.
    2. Создается экземпляр формы `LoginForm`.
    3. Если запрос является POST-запросом и форма успешно прошла валидацию (`form.validate_on_submit()`):
        a. Извлекаются данные из полей формы (имя пользователя/email и пароль).
        b. Производится поиск пользователя в базе данных по имени пользователя или email.
        c. Если пользователь найден и введенный пароль корректен:
            i. Пользователь регистрируется в системе с помощью `login_user()`.
            ii. Отображается приветственное flash-сообщение.
            iii. Пользователь перенаправляется на страницу, которую он пытался посетить до входа (`next_page`),
               или на главную страницу реестра, если `next_page` не указана или небезопасна.
        d. Если пользователь не найден или пароль неверен:
            i. Отображается flash-сообщение об ошибке.
            ii. Пользователь перенаправляется обратно на страницу входа.
    4. Если запрос является GET-запросом или форма не прошла валидацию:
        a. Отображается HTML-шаблон страницы входа (`auth/login.html`) с формой.
    """
    # Проверяем, аутентифицирован ли текущий пользователь.
    # `current_user` — это прокси-объект Flask-Login. `is_authenticated` — это его свойство,
    # которое возвращает `True`, если пользователь вошел в систему, и `False` в противном случае.
    if current_user.is_authenticated:
        # Если пользователь уже вошел, нет смысла показывать ему страницу входа снова.
        # Перенаправляем его на главную страницу реестра.
        # `url_for('main.show_registry')` генерирует URL для функции `show_registry`
        # из Blueprint'а с именем 'main'.
        return redirect(url_for('main.show_registry'))

    # Создаём экземпляр формы входа `LoginForm`.
    # Эта форма определена в `src/forms.py` и содержит поля для ввода имени пользователя/email и пароля,
    # а также, возможно, флажок "Запомнить меня".
    form = LoginForm()

    # `form.validate_on_submit()` — это удобный метод WTForms-Flask. Он делает две вещи:
    # 1. Проверяет, был ли запрос сделан методом POST (`request.method == 'POST'`).
    # 2. Если да, то вызывает метод `form.validate()`, который запускает все валидаторы,
    #    определенные для полей формы.
    # Возвращает `True`, если оба условия выполнены, иначе `False`.
    if form.validate_on_submit():
        # Если форма отправлена и валидна, извлекаем данные из нее.
        # `form.username_or_email.data` получает значение, введенное пользователем в поле 'username_or_email'.
        login_identifier = form.username_or_email.data

        # Ищем пользователя в базе данных.
        # `db.session.scalar(...)` выполняет запрос и возвращает первый результат первой колонки
        # или `None`, если результатов нет. Это удобно, когда ожидается не более одного результата.
        # `db.select(User)` создает объект запроса SQLAlchemy для выборки из таблицы `User`.
        # `.filter(...)` добавляет условие WHERE к запросу.
        # `(User.username == login_identifier) | (User.email == login_identifier)` — это условие OR,
        # которое ищет пользователя либо по совпадению имени пользователя, либо по совпадению email.
        user = db.session.scalar(
            db.select(User).filter(
                (User.username == login_identifier) | (User.email == login_identifier)
            )
        )

        # Проверяем, найден ли пользователь и совпадает ли пароль.
        # `user is None` — пользователь с таким именем/email не найден в базе.
        # `not user.check_password(form.password.data)` — пользователь найден, но введенный пароль
        # (из `form.password.data`) не совпадает с хешированным паролем, хранящимся в базе.
        # Метод `check_password` определен в модели `User` и сравнивает предоставленный пароль с хешем.
        if user is None or not user.check_password(form.password.data):
            # Если аутентификация не удалась, показываем сообщение об ошибке.
            # `flash()` добавляет сообщение в специальный список, который будет доступен
            # на следующей отображаемой странице. Второй аргумент 'error' — это категория сообщения,
            # которая может использоваться для стилизации (например, красный цвет для ошибок).
            flash('Неверное имя пользователя/email или пароль.', 'error')
            # Перенаправляем пользователя обратно на страницу входа.
            # `url_for('.login')` генерирует URL для функции `login` внутри текущего Blueprint'а ('auth').
            # Точка перед именем функции указывает на текущий Blueprint.
            return redirect(url_for('.login'))

        # Если пользователь найден и пароль верен, аутентификация прошла успешно.
        # "Входим" пользователя в систему с помощью функции `login_user()` из Flask-Login.
        # `user` — это объект пользователя, который был загружен из базы данных.
        # `remember=form.remember_me.data` — если пользователь установил флажок "Запомнить меня"
        # (значение `form.remember_me.data` будет `True`), Flask-Login установит постоянный cookie,
        # чтобы сессия пользователя сохранялась даже после закрытия браузера.
        login_user(user, remember=form.remember_me.data)
        # Показываем приветственное flash-сообщение.
        flash(f'Добро пожаловать, {user.username}!', 'success') # 'success' — категория для успешных операций.

        # Обрабатываем параметр `next` из URL-запроса.
        # Flask-Login автоматически добавляет параметр `next` к URL страницы входа,
        # если пользователь пытался получить доступ к защищенной странице, будучи неаутентифицированным.
        # `request.args.get('next')` извлекает значение этого параметра.
        next_page = request.args.get('next')
        # Важная проверка безопасности: убеждаемся, что `next_page` не ведет на внешний сайт.
        # `urlparse(next_page).netloc` возвращает сетевое расположение (домен) из URL.
        # Если `next_page` не задан (`not next_page`) или если `netloc` не пустой (т.е. это абсолютный URL
        # с доменом, возможно, внешним), то считаем `next_page` небезопасным или отсутствующим.
        if not next_page or urlparse(next_page).netloc != '':
            # В таком случае перенаправляем на страницу по умолчанию — главную страницу реестра.
            next_page = url_for('main.show_registry')
        # Выполняем перенаправление на `next_page`.
        return redirect(next_page)

    # Если запрос был методом GET (пользователь просто открыл страницу)
    # или если `form.validate_on_submit()` вернул `False` (данные формы невалидны),
    # то отображаем HTML-шаблон страницы входа.
    # `render_template()` загружает шаблон 'auth/login.html' и передает в него
    # переменные `title` (заголовок страницы) и `form` (экземпляр формы для отображения).
    return render_template('auth/login.html', title='Вход', form=form)


# Определяем маршрут для выхода пользователя из системы.
# `@auth_bp.route('/logout')` связывает URL '/auth/logout' с функцией `logout()`.
# Этот маршрут обычно обрабатывает только GET-запросы, так как выход — это простое действие.
@auth_bp.route('/logout')
# `@login_required` — декоратор Flask-Login. Он гарантирует, что только аутентифицированные
# пользователи могут получить доступ к этому маршруту. Если неаутентифицированный пользователь
# попытается перейти по `/auth/logout`, он будет перенаправлен на страницу входа.
@login_required
def logout():
    """
    Функция-обработчик для выхода пользователя из системы (/auth/logout).

    Логика работы:
    1. Вызывается функция `logout_user()` из Flask-Login, которая удаляет данные пользователя из сессии.
    2. Отображается flash-сообщение об успешном выходе.
    3. Пользователь перенаправляется на главную страницу реестра.
    """
    # Вызываем функцию `logout_user()` из Flask-Login.
    # Эта функция очищает сессию пользователя, фактически "выводя" его из системы.
    logout_user()
    # Показываем информационное flash-сообщение.
    flash('Вы успешно вышли из системы.', 'info') # 'info' — категория для информационных сообщений.
    # Перенаправляем пользователя на главную страницу реестра.
    return redirect(url_for('main.show_registry'))


# Определяем маршрут для страницы регистрации нового пользователя.
# `@auth_bp.route('/register', methods=['GET', 'POST'])` связывает URL '/auth/register'
# с функцией `register()`. Поддерживаются GET (отображение формы) и POST (отправка формы) запросы.
@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    """
    Функция-обработчик для страницы регистрации нового пользователя (/auth/register).

    Логика работы:
    1. Если пользователь уже аутентифицирован, он перенаправляется на главную страницу реестра.
    2. Создается экземпляр формы `RegistrationForm`.
    3. Если запрос является POST-запросом и форма успешно прошла валидацию (`form.validate_on_submit()`):
        a. Извлекаются данные из полей формы (имя пользователя, email, пароль).
        b. Создается новый объект `User`.
        c. Устанавливается пароль для нового пользователя (пароль хешируется перед сохранением).
        d. Новый пользователь добавляется в сессию базы данных и сохраняется (`db.session.add()`, `db.session.commit()`).
        e. Отображается flash-сообщение об успешной регистрации.
        f. Пользователь перенаправляется на страницу входа.
    4. Если запрос является GET-запросом или форма не прошла валидацию:
        a. Отображается HTML-шаблон страницы регистрации (`auth/register.html`) с формой.
    """
    # Если текущий пользователь уже аутентифицирован, ему не нужно регистрироваться снова.
    if current_user.is_authenticated:
        return redirect(url_for('main.show_registry'))

    # Создаём экземпляр формы регистрации `RegistrationForm`.
    # Эта форма определена в `src/forms.py` и содержит поля для ввода имени пользователя,
    # email, пароля и подтверждения пароля, а также соответствующие валидаторы
    # (например, проверка уникальности имени пользователя и email, совпадение паролей).
    form = RegistrationForm()

    # Если форма отправлена (POST) и валидна.
    if form.validate_on_submit():
        # Создаём новый экземпляр модели `User`.
        # `form.username.data` и `form.email.data` — это значения, введенные пользователем
        # в соответствующие поля формы и прошедшие первичную валидацию (например, формат email).
        user = User(username=form.username.data, email=form.email.data)
        # Устанавливаем пароль для нового пользователя.
        # `user.set_password(form.password.data)` вызывает метод модели `User`,
        # который хеширует предоставленный пароль (`form.password.data`) и сохраняет хеш.
        # Никогда не храните пароли в открытом виде!
        user.set_password(form.password.data)
        # Добавляем новый объект `user` в сессию SQLAlchemy.
        # На этом этапе изменения еще не записаны в базу данных.
        db.session.add(user)
        # Фиксируем изменения в базе данных (выполняется INSERT-запрос).
        # Если произойдет ошибка на этом этапе (например, нарушение уникальности, которое
        # не было поймано валидатором формы, хотя должно было), транзакция будет отменена.
        db.session.commit()
        # Показываем flash-сообщение об успехе.
        flash('Поздравляем, вы успешно зарегистрированы! Теперь вы можете войти.', 'success')
        # Перенаправляем нового пользователя на страницу входа, чтобы он мог войти в систему.
        return redirect(url_for('.login')) # '.login' ссылается на маршрут login в текущем Blueprint'е.

    # Если GET-запрос или форма невалидна, отображаем страницу регистрации с формой.
    # Передаем в шаблон `title` и `form`.
    return render_template('auth/register.html', title='Регистрация', form=form)

# TODO: В будущем можно добавить маршруты для смены или сброса пароля.
# Это напоминание о том, что функционал аутентификации может быть расширен.
# Например, можно добавить:
# - Запрос на сброс пароля (пользователь вводит email, ему отправляется ссылка).
# - Форма для ввода нового пароля (доступна по уникальной ссылке).
# - Страница для смены пароля для уже вошедшего пользователя.

# -*- coding: utf-8 -*-
# Стандартная директива для указания кодировки UTF-8.
"""
Модуль определения основных маршрутов (endpoints) веб-приложения с использованием Flask Blueprint.

Этот модуль отвечает за обработку HTTP-запросов к основным страницам и функциям приложения,
таким как:
- Главная страница (которая перенаправляет на реестр).
- Страница отображения реестра образовательных организаций с возможностями:
    - Фильтрации по региону, УГСН, специальности.
    - Сортировки по различным полям (наименование, ОГРН, ИНН, регион).
    - Пагинации (постраничного вывода) результатов.
- CRUD-операции (Create, Read, Update, Delete) для образовательных организаций.
- CRUD-операции для регионов (в разделе "администрирования").

Используется механизм Flask Blueprint (`main_bp`) для логической группировки этих маршрутов.
Это помогает структурировать приложение, особенно когда оно становится большим.
Маршруты защищены с помощью `@login_required` там, где это необходимо (например, для CRUD-операций).
Взаимодействие с базой данных осуществляется через модели SQLAlchemy (`EducationalOrganization`, `Region`, и т.д.)
и объект сессии `db.session`. Для обработки пользовательского ввода и его валидации используются
формы, определенные в `src.forms` (`FilterRegistryForm`, `OrganizationForm`, `RegionForm`).
"""

# Импортируем необходимые компоненты из библиотеки Flask:
# - `Blueprint`: Класс для создания компонента приложения ("чертежа"). Позволяет группировать маршруты,
#   шаблоны и статические файлы, делая приложение более структурированным и масштабируемым.
#   Каждый Blueprint может иметь свой префикс URL и собственный набор шаблонов и статических файлов.
# - `render_template`: Функция для генерации HTML-ответа на основе Jinja2 шаблона.
#   Она принимает имя файла шаблона и переменные, которые будут доступны в этом шаблоне.
# - `request`: Глобальный объект, представляющий текущий HTTP-запрос от клиента.
#   Содержит информацию о методе запроса (GET, POST), заголовках, данных формы, аргументах URL и т.д.
# - `url_for`: Функция для генерации URL-адресов на основе имени функции-обработчика маршрута (view function)
#   или имени конечной точки (endpoint). Это предпочтительный способ создания URL, так как он
#   устойчив к изменениям в структуре маршрутов.
# - `redirect`: Функция для выполнения HTTP-перенаправления на другой URL.
# - `flash`: Функция для отображения временных сообщений пользователю (flash messages).
#   Эти сообщения обычно отображаются на следующей странице после их установки и полезны
#   для информирования пользователя об успехе или неудаче операции (например, "Вы успешно вошли в систему").
# - `abort`: Функция для прерывания запроса и возврата HTTP-ошибки (например, 403 Forbidden, 404 Not Found).
#   Используется, когда дальнейшая обработка запроса невозможна или не разрешена.
from flask import Blueprint, render_template, request, url_for, redirect, flash, abort

# Импортируем функции `asc` (по возрастанию), `desc` (по убыванию) и `distinct` из SQLAlchemy.
# - `asc(column)`: Используется в `query.order_by()` для сортировки по столбцу `column` в порядке возрастания.
# - `desc(column)`: Используется в `query.order_by()` для сортировки по столбцу `column` в порядке убывания.
# - `distinct()`: Используется в запросах (`db.select(...).distinct()`) для того, чтобы каждая строка
#   в результирующем наборе была уникальной, устраняя дубликаты, которые могут возникнуть,
#   например, из-за операций JOIN.
from sqlalchemy import asc, desc, distinct

# Импортируем компоненты из расширения Flask-Login:
# - `login_required`: Декоратор, который можно применять к функциям-обработчикам маршрутов
#   для ограничения доступа только аутентифицированным пользователям. Если неаутентифицированный
#   пользователь пытается получить доступ к такому маршруту, Flask-Login перенаправит его
#   на страницу входа (заданную в `login_manager.login_view`).
# - `current_user`: Прокси-объект, который представляет текущего аутентифицированного пользователя.
#   Если пользователь не вошел в систему, `current_user.is_authenticated` будет `False`.
#   Этот объект доступен в шаблонах и функциях-обработчиках для получения информации о пользователе.
from flask_login import login_required, current_user

# Импортируем модели данных (`EducationalOrganization`, `Region`, `Specialty`, `SpecialtyGroup`, `EducationalProgram`)
# из локального модуля `.models`. Эти классы представляют таблицы базы данных и используются
# для выполнения запросов (SELECT, INSERT, UPDATE, DELETE) и для работы с данными как с объектами Python.
# Точка перед `models` означает относительный импорт из текущего пакета (директории `src`).
from .models import EducationalOrganization, Region, Specialty, SpecialtyGroup, EducationalProgram

# Импортируем объект `db` (экземпляр SQLAlchemy) из локального модуля `.database`.
# Этот объект предоставляет интерфейс для взаимодействия с базой данных:
# создание сессий (`db.session`), выполнение запросов (`db.session.execute()`, `db.select()`),
# управление транзакциями (`db.session.commit()`, `db.session.rollback()`),
# а также содержит базовый класс для моделей (`db.Model`).
from .database import db

# Импортируем классы форм (`FilterRegistryForm`, `OrganizationForm`, `RegionForm`)
# из локального модуля `.forms`. Эти формы используются для:
# - Сбора данных от пользователя через HTML-формы.
# - Валидации этих данных на сервере.
# - Удобного доступа к данным формы в функциях-обработчиках.
from .forms import FilterRegistryForm, OrganizationForm, RegionForm

# Создаем экземпляр `Blueprint` с именем 'main'.
# Blueprint'ы во Flask используются для организации и структурирования приложений
# путем группировки связанных маршрутов, шаблонов и статических файлов.
# - Первый аргумент `'main'` — это имя данного Blueprint'а. Оно используется внутренне Flask,
#   а также для генерации URL-адресов с помощью `url_for` (например, `url_for('main.index')`).
# - Второй аргумент `__name__` — это имя текущего модуля Python (`src.routes`). Flask использует его
#   для определения местоположения ресурсов, связанных с Blueprint'ом (например, если бы
#   шаблоны или статические файлы были специфичны для этого Blueprint'а и хранились бы
#   в поддиректориях относительно этого файла).
# `url_prefix` здесь не указан, поэтому все маршруты, определенные в этом Blueprint'е,
# будут зарегистрированы относительно корня URL-адреса приложения.
# Например, `@main_bp.route('/')` будет соответствовать URL `/`.
# Если бы был указан `url_prefix='/app'`, то `@main_bp.route('/')` соответствовал бы `/app/`.
main_bp = Blueprint('main', __name__)

# --- Маршруты веб-приложения ---

# Определяем маршрут для главной страницы ('/').
# Декоратор `@main_bp.route('/')` связывает URL-путь `/` (корень сайта)
# с функцией `index()`, которая будет обрабатывать запросы к этому URL.
@main_bp.route('/')
def index():
    """
    Обработчик для главной (корневой) страницы сайта (URL: /).

    В текущей реализации эта функция не отображает собственную страницу,
    а немедленно перенаправляет пользователя на страницу реестра образовательных
    организаций (маршрут `show_registry`). Это сделано для того, чтобы
    пользователь сразу попадал к основному функционалу приложения.

    В будущем эта страница может быть доработана для отображения:
    - Приветственного сообщения.
    - Общей информации о проекте или системе.
    - Краткой статистики по данным реестра.
    - Новостей или важных объявлений.
    - Ссылок на основные разделы сайта.

    Возвращает:
        werkzeug.wrappers.Response: HTTP-ответ с перенаправлением (HTTP status code 302 Found)
                                    на URL, сгенерированный для маршрута `.show_registry`.
                                    Браузер пользователя автоматически перейдет по этому новому URL.
    """
    # `redirect(location)`: Эта функция из Flask создает HTTP-ответ, который
    # предписывает браузеру пользователя перейти на другой URL (`location`).
    # `url_for('.show_registry')`: Эта функция генерирует URL-адрес для указанной
    # функции-обработчика (view function).
    #   - Точка `.` перед `show_registry` означает, что функция `show_registry`
    #     ищется внутри текущего Blueprint'а (то есть `main_bp`).
    #   - Flask автоматически найдет маршрут, связанный с `main_bp.show_registry`
    #     (в данном случае `/registry`), и вернет этот URL.
    # Использование `url_for()` вместо жестко закодированных URL-адресов является
    # лучшей практикой, так как это делает код более гибким к изменениям
    # в структуре маршрутов (если URL для `show_registry` изменится, `url_for`
    # автоматически сгенерирует правильный новый URL).
    return redirect(url_for('.show_registry'))

# Определяем маршрут для страницы реестра ('/registry').
# Этот маршрут будет доступен по URL-адресу `/registry` (относительно корня приложения,
# так как `main_bp` не имеет `url_prefix`).
# Он настроен на обработку только GET-запросов. Параметры для фильтрации,
# сортировки и пагинации передаются через URL query string (например, `/registry?page=2&region=5`).
# Использование GET для таких операций позволяет пользователям легко делиться ссылками
# на конкретные состояния реестра и добавлять их в закладки.
@main_bp.route('/registry')
def show_registry():
    """
    Обработчик для отображения страницы реестра образовательных организаций.

    Эта функция является центральной для представления основного контента приложения.
    Она выполняет комплексную задачу по подготовке и отображению данных:
    1.  **Извлечение параметров из URL**: Получает значения для номера страницы (`page`),
        ключа сортировки (`sort_by`) и порядка сортировки (`sort_order`) из
        query string текущего HTTP-запроса. Если параметры отсутствуют,
        используются значения по умолчанию.
    2.  **Инициализация формы фильтрации**: Создает экземпляр формы `FilterRegistryForm`.
        В конструктор формы передаются `request.args` (параметры URL), что позволяет
        форме автоматически заполниться текущими значениями фильтров, если они были
        установлены пользователем ранее. Это обеспечивает "запоминание" состояния фильтров.
    3.  **Заполнение выпадающих списков формы**: Динамически загружает из базы данных
        списки регионов, укрупненных групп специальностей (УГСН) и конкретных
        специальностей. Эти данные используются для формирования вариантов выбора (`choices`)
        в соответствующих полях `SelectField` формы фильтрации. Это позволяет пользователю
        выбирать критерии фильтрации из актуальных данных.
    4.  **Построение основного запроса к БД**: Формирует базовый SQL-запрос (используя
        SQLAlchemy ORM) для выборки записей из таблицы `EducationalOrganization`.
        Используется `distinct()` для предотвращения дублирования организаций в результатах,
        которое может возникнуть из-за JOIN'ов при сложной фильтрации.
    5.  **Применение фильтров**: Динамически модифицирует основной запрос, добавляя
        к нему условия фильтрации (`.filter()`) на основе значений, выбранных
        пользователем в `filter_form`. Если фильтр не активен (например, выбрано "Все регионы"),
        соответствующее условие не добавляется. При необходимости выполняются JOIN'ы
        с другими таблицами (например, `EducationalProgram`, `Specialty`) для фильтрации
        по связанным данным.
    6.  **Применение сортировки**: Добавляет к запросу условие сортировки (`.order_by()`)
        на основе параметров `sort_by` и `sort_order`. При сортировке по полям
        из связанных таблиц (например, по названию региона) также выполняется JOIN.
    7.  **Пагинация**: Выполняет итоговый запрос с использованием `db.paginate()`.
        Эта функция извлекает из базы данных только ту "порцию" данных, которая
        соответствует запрошенной странице и заданному количеству записей на страницу.
        Это критически важно для производительности при работе с большими наборами данных.
    8.  **Рендеринг шаблона**: Передает полученный список организаций для текущей страницы,
        объект пагинации (для навигационных ссылок), текущие параметры сортировки
        и экземпляр формы фильтрации в HTML-шаблон `registry.html`. Шаблон Jinja2
        использует эти данные для динамической генерации HTML-кода страницы,
        отображая таблицу с организациями, элементы управления пагинацией,
        ссылки для сортировки и форму фильтров.

    Возвращает:
        str: Строка, содержащая HTML-код страницы реестра, сгенерированный
             на основе шаблона `registry.html` и переданных в него контекстных данных.
    """
    # --- 1. Извлечение параметров из URL для пагинации и сортировки ---
    # `request.args` — это объект типа `werkzeug.datastructures.MultiDict`,
    # который содержит все параметры, переданные в URL после знака вопроса (query string).
    # `get(key, default_value, type=conversion_function)` — безопасный способ
    # получить значение параметра.

    # Получаем номер текущей страницы. Если параметр 'page' отсутствует, по умолчанию используется 1.
    # `type=int` преобразует значение параметра в целое число.
    page = request.args.get('page', 1, type=int)

    # Получаем ключ (имя поля), по которому будет производиться сортировка.
    # По умолчанию сортировка выполняется по полю 'name' (предположительно, наименование организации).
    sort_by = request.args.get('sort_by', 'name')

    # Получаем направление сортировки: 'asc' (по возрастанию) или 'desc' (по убыванию).
    # По умолчанию — 'asc'.
    sort_order = request.args.get('sort_order', 'asc')

    # --- 2. Инициализация формы фильтрации ---
    # Создаем экземпляр формы `FilterRegistryForm`.
    # Передача `request.args` в конструктор позволяет форме автоматически
    # загрузить значения для своих полей из параметров URL, если они там есть.
    # Например, если URL содержит `?region=5`, то поле `region` в форме
    # будет инициализировано значением `5`.
    filter_form = FilterRegistryForm(request.args)

    # --- 3. Заполнение выпадающих списков (choices) для полей формы ---
    # Для полей типа `SelectField` в форме необходимо предоставить список
    # возможных вариантов выбора (`choices`). Эти варианты загружаются из базы данных.

    # Загружаем все регионы из таблицы `Region`, отсортированные по названию.
    # `db.session.execute(query).scalars().all()` — современный способ выполнения запросов в SQLAlchemy 2.x.
    # `db.select(Region)` создает SELECT-запрос.
    # `.order_by(Region.name)` добавляет сортировку.
    # `.scalars()` извлекает сами объекты `Region` (а не кортежи).
    # `.all()` возвращает список всех найденных объектов `Region`.
    regions = db.session.execute(db.select(Region).order_by(Region.name)).scalars().all()

    # Аналогично загружаем укрупненные группы специальностей (УГСН).
    specialty_groups = db.session.execute(db.select(SpecialtyGroup).order_by(SpecialtyGroup.name)).scalars().all()

    # Аналогично загружаем конкретные специальности.
    specialties = db.session.execute(db.select(Specialty).order_by(Specialty.name)).scalars().all()

    # Модель `StudyForm` была удалена из проекта, поэтому код, связанный с загрузкой
    # и использованием форм обучения, здесь отсутствует или закомментирован.
    # # study_forms = db.session.execute(db.select(StudyForm).order_by(StudyForm.name)).scalars().all()

    # Присваиваем загруженные списки атрибуту `choices` соответствующих полей формы.
    # `choices` должен быть списком кортежей `(value, label)`.
    # `value` — это значение, которое будет отправлено на сервер (обычно ID объекта).
    # `label` — это текст, который увидит пользователь в выпадающем списке.
    # Конструктор `FilterRegistryForm` уже позаботился о добавлении опции "Все ..."
    # (например, "Все регионы") в начало каждого списка `choices`.
    filter_form.region.choices = [(r.id, r.name) for r in regions]
    filter_form.specialty_group.choices = [(sg.id, f"{sg.code} {sg.name}") for sg in specialty_groups]
    filter_form.specialty.choices = [(s.id, f"{s.code} {s.name}") for s in specialties]
    # Код для `filter_form.study_form.choices` удален, так как модель StudyForm была удалена.
    # Дублирующиеся строки filter_form.specialty_group.choices и filter_form.specialty.choices удалены.

    # --- 4. Построение динамического запроса к БД с учётом фильтров ---
    # Этот раздел отвечает за формирование основного SQL-запроса к базе данных
    # для извлечения списка образовательных организаций. Запрос строится
    # динамически, то есть его структура (условия WHERE, JOIN'ы) зависит от того,
    # какие фильтры выбрал пользователь.

    # Начинаем строить базовый запрос для выборки всех уникальных образовательных организаций.
    # `db.select(EducationalOrganization)` создает объект SELECT-запроса SQLAlchemy,
    # который будет выбирать все столбцы из таблицы, соответствующей модели `EducationalOrganization`.
    # `.distinct()` добавляет к запросу ключевое слово DISTINCT (или его аналог в зависимости от СУБД).
    # Это гарантирует, что каждая организация будет возвращена в результатах только один раз,
    # даже если из-за операций JOIN (которые могут потребоваться для фильтрации по связанным
    # данным, таким как программы или специальности) одна и та же организация может
    # появиться в промежуточных результатах несколько раз.
    query = db.select(EducationalOrganization).distinct()

    # Последовательно применяем фильтры к запросу `query` на основе значений,
    # выбранных пользователем в форме `filter_form`.
    # `filter_form.<field_name>.data` содержит значение, которое пользователь выбрал
    # в соответствующем поле формы (или значение по умолчанию, если ничего не выбрано).
    # Для полей `SelectField` с `coerce=int`, `data` будет целым числом (ID выбранной записи)
    # или значением по умолчанию (например, 0 для опции "Все ...").
    # Фильтр применяется только если выбрано конкретное значение (т.е. не "Все ...").

    # Фильтр по региону:
    # Если в поле `region` формы выбрано конкретное значение (т.е. `filter_form.region.data`
    # не является `None` и не равно 0, что соответствует опции "Все регионы"),
    # то добавляем к запросу условие `WHERE EducationalOrganization.region_id = <выбранный_id>`.
    if filter_form.region.data and filter_form.region.data != 0:
        query = query.filter(EducationalOrganization.region_id == filter_form.region.data)

    # Фильтр по укрупнённой группе специальностей (УГСН):
    # Если в поле `specialty_group` формы выбрано конкретное значение.
    if filter_form.specialty_group.data and filter_form.specialty_group.data != 0:
        # Для фильтрации по УГСН необходимо связать (JOIN) несколько таблиц:
        # 1. `EducationalOrganization` с `EducationalProgram` (через связь `programs`,
        #    определенную в модели `EducationalOrganization`). Это даст нам доступ
        #    к программам, которые реализует каждая организация.
        # 2. `EducationalProgram` с `Specialty` (через связь `specialty`,
        #    определенную в модели `EducationalProgram`). Это даст нам доступ
        #    к специальностям, к которым относятся эти программы.
        # После выполнения этих JOIN'ов, мы можем добавить условие фильтрации
        # по полю `group_id` (ID укрупненной группы) в таблице `Specialty`.
        query = query.join(EducationalOrganization.programs)\
                     .join(EducationalProgram.specialty)\
                     .filter(Specialty.group_id == filter_form.specialty_group.data)

    # Фильтр по конкретной специальности:
    # Если в поле `specialty` формы выбрано конкретное значение.
    if filter_form.specialty.data and filter_form.specialty.data != 0:
        # Проверяем, был ли уже выполнен JOIN с таблицей `EducationalProgram` на предыдущем шаге
        # (при фильтрации по УГСН). Если фильтр по УГСН не был активен (т.е.
        # `filter_form.specialty_group.data` равно 0 или `None`), то JOIN с `EducationalProgram`
        # еще не был сделан. В этом случае его нужно добавить сейчас, чтобы можно было
        # отфильтровать по `EducationalProgram.specialty_id`.
        if not (filter_form.specialty_group.data and filter_form.specialty_group.data != 0):
            query = query.join(EducationalOrganization.programs)
        # Добавляем условие фильтрации по `EducationalProgram.specialty_id`.
        query = query.filter(EducationalProgram.specialty_id == filter_form.specialty.data)
    
    # Фильтр по форме обучения был удален из проекта, так как модель `StudyForm`
    # и связанные с ней функциональные части (поля в формах, логика фильтрации)
    # были удалены. Закомментированный код ниже оставлен исключительно для
    # исторического контекста и понимания того, как это могло бы быть реализовано,
    # если бы такая фильтрация требовалась.
    # # if hasattr(filter_form, 'study_form') and filter_form.study_form.data and filter_form.study_form.data != 0:
    # #     # Для фильтрации по форме обучения необходимо выполнить JOIN с EducationalProgram,
    # #     # а затем с таблицей форм обучения (предположим, StudyForm) через
    # #     # связь многие-ко-многим (например, EducationalProgram.study_forms).
    # #
    # #     # Проверяем, был ли уже JOIN с EducationalProgram (аналогично фильтру по специальности).
    # #     already_joined_programs = False
    # #     if (filter_form.specialty_group.data and filter_form.specialty_group.data != 0) or \
    # #        (filter_form.specialty.data and filter_form.specialty.data != 0):
    # #         already_joined_programs = True
    # #
    # #     if not already_joined_programs:
    # #         query = query.join(EducationalOrganization.programs)
    # #
    # #     # Предполагается, что в модели EducationalProgram есть связь 'study_forms',
    # #     # ведущая к модели StudyForm (через ассоциативную таблицу).
    # #     # from .models import StudyForm # Убедиться, что модель StudyForm импортирована.
    # #     # query = query.join(EducationalProgram.study_forms)\
    # #     #              .filter(StudyForm.id == filter_form.study_form.data)
    # #     pass # Логика фильтра по форме обучения здесь отсутствует.

    # --- 5. Применение сортировки ---
    # Этот блок кода отвечает за добавление к запросу `query` условий сортировки
    # на основе параметров `sort_by` (поле для сортировки) и `sort_order` (направление),
    # полученных из URL-запроса.

    # Определяем, по какому столбцу модели SQLAlchemy будет производиться сортировка.
    # По умолчанию, если `sort_by` не указан или имеет неизвестное значение,
    # сортировка будет выполняться по полному наименованию организации (`EducationalOrganization.full_name`).
    sort_column = EducationalOrganization.full_name

    if sort_by == 'ogrn':
        # Если в `sort_by` указано 'ogrn', сортируем по полю `ogrn` модели `EducationalOrganization`.
        sort_column = EducationalOrganization.ogrn
    elif sort_by == 'inn':
        # Если 'inn', сортируем по полю `inn`.
        sort_column = EducationalOrganization.inn
    elif sort_by == 'region':
        # Если 'region', сортируем по названию региона (`Region.name`).
        # Для этого необходимо выполнить JOIN с таблицей `Region`.
        # Используется `outerjoin`, чтобы организации, у которых `region_id` не указан (равен NULL),
        # не были исключены из результатов, если бы использовался `join` (INNER JOIN).
        # Условие `EducationalOrganization.region_id == Region.id` явно указывает, как связывать таблицы.
        # Этот JOIN добавляется к запросу `query`.
        # (Примечание: условие `and not filter_form.region.data` было здесь ранее, но для сортировки
        # по имени региона JOIN с Region нужен всегда, если `sort_by == 'region'`, независимо от фильтра.
        # Если фильтр по региону уже применил `filter` по `region_id`, этот `outerjoin`
        # не должен конфликтовать, но может быть избыточным, если СУБД не оптимизирует его.
        # Однако, для доступа к `Region.name` он необходим.)
        query = query.outerjoin(Region, EducationalOrganization.region_id == Region.id)
        sort_column = Region.name # Устанавливаем столбец сортировки как `Region.name`.

    # Применяем направление сортировки к запросу.
    # `asc()` и `desc()` — это функции SQLAlchemy, которые оборачивают столбец,
    # указывая направление сортировки.
    if sort_order == 'desc':
        # Если `sort_order` равен 'desc', сортируем в порядке убывания.
        query = query.order_by(desc(sort_column))
    else:
        # В противном случае (если `sort_order` равен 'asc' или любому другому значению,
        # отличному от 'desc'), сортируем в порядке возрастания.
        query = query.order_by(asc(sort_column))
        # Явно устанавливаем `sort_order` в 'asc' для передачи в шаблон.
        # Это гарантирует, что в шаблоне всегда будет корректное значение для генерации
        # ссылок сортировки (например, для переключения направления).
        sort_order = 'asc'

    # --- 6. Пагинация результатов ---
    # Пагинация используется для разделения большого количества результатов запроса
    # на несколько страниц, чтобы улучшить производительность и удобство пользователя.
    # `db.paginate(query, ...)` — это функция, предоставляемая Flask-SQLAlchemy
    # (или совместимым расширением), которая упрощает пагинацию.
    # Она выполняет запрос `query`, но извлекает только ту часть данных,
    # которая соответствует указанной странице и количеству элементов на странице.
    # Возвращает объект пагинации, содержащий элементы для текущей страницы
    # и информацию для навигации (например, общее количество страниц, номера
    # предыдущей/следующей страниц).
    # `db.paginate(query, page, per_page, error_out, max_per_page)`:
    #   - `query`: Сконструированный SQLAlchemy запрос, который нужно выполнить и пагинировать.
    #   - `page=page`: Номер текущей страницы, полученный из URL-параметра.
    #   - `per_page=20`: Количество записей, которое будет отображаться на одной странице.
    #     Это значение можно сделать настраиваемым, например, через конфигурационный файл
    #     или дать пользователю возможность выбирать его.
    #   - `error_out=False`: Если `True` (по умолчанию), то при запросе несуществующей
    #     страницы (например, номер страницы больше, чем общее количество страниц, или
    #     отрицательный номер) будет вызвана ошибка 404 Not Found. Если `False`,
    #     то вместо ошибки будет возвращена пустая страница (если номер страницы слишком большой)
    #     или первая страница (если номер некорректен, например, отрицательный).
    #     В данном случае `False` обеспечивает более мягкое поведение.
    #   - `max_per_page=100`: Ограничивает максимальное значение, которое может быть
    #     установлено для `per_page`. Это мера безопасности для предотвращения запроса
    #     слишком большого количества данных за один раз, что могло бы создать
    #     чрезмерную нагрузку на сервер. Если бы `per_page` также принимался из URL,
    #     это было бы особенно важно.
    pagination = db.paginate(query, page=page, per_page=20, error_out=False, max_per_page=100)

    # `pagination.items` — это атрибут объекта пагинации, который содержит список
    # объектов (в данном случае экземпляров `EducationalOrganization`) для текущей
    # отображаемой страницы.
    organizations = pagination.items

    # --- 7. Рендеринг шаблона и передача данных ---
    # Функция `render_template(template_name_or_list, **context)` загружает
    # указанный HTML-шаблон (здесь `registry.html`, который должен находиться
    # в папке `templates`) и передает в него все последующие именованные аргументы
    # в виде словаря контекста. Эти переменные будут доступны в шаблоне Jinja2
    # для динамической генерации HTML-кода.
    return render_template('registry.html',      # Имя файла шаблона.
                           organizations=organizations,  # Список объектов организаций для отображения на текущей странице.
                           pagination=pagination,      # Объект пагинации. Шаблон будет использовать его для генерации
                                                       # ссылок на другие страницы (например, `pagination.prev_num`,
                                                       # `pagination.next_num`, `pagination.iter_pages()`).
                           sort_by=sort_by,            # Текущее поле, по которому выполнена сортировка.
                                                       # Используется в шаблоне для подсветки активного столбца сортировки
                                                       # и для формирования URL-адресов для изменения поля сортировки.
                           sort_order=sort_order,      # Текущее направление сортировки ('asc' или 'desc').
                                                       # Используется в шаблоне для отображения текущего направления
                                                       # и для формирования URL-адресов для переключения направления.
                           filter_form=filter_form     # Экземпляр формы `FilterRegistryForm`.
                                                       # Используется в шаблоне для отображения полей фильтров
                                                       # и их текущих выбранных значений.
                           )

# --- Маршруты для CRUD (Create, Read, Update, Delete) операций над образовательными организациями ---
# Этот раздел содержит функции-обработчики для создания, просмотра (хотя явного "просмотра одной организации" здесь нет,
# он интегрирован в реестр и редактирование), обновления и удаления записей об образовательных организациях.
# Все эти операции обычно требуют аутентификации пользователя и, в идеале, проверки соответствующих прав доступа.

def _populate_organization_form_choices(form):
    """
    Вспомогательная (условно "приватная", по соглашению об именовании с начальным подчеркиванием) функция
    для динамического заполнения вариантов выбора (`choices`) в полях `SelectField`
    формы `OrganizationForm` (или любой другой формы с аналогичными полями `region` и `parent`).

    Эта функция инкапсулирует логику загрузки данных из базы для выпадающих списков,
    чтобы избежать дублирования кода в маршрутах добавления (`add_organization`)
    и редактирования (`edit_organization`) организаций.

    Действия функции:
    1.  **Загрузка регионов**: Выполняет запрос к базе данных для получения списка всех
        регионов (`Region`), отсортированных по названию.
    2.  **Загрузка головных организаций**: Выполняет запрос к базе данных для получения
        списка всех образовательных организаций (`EducationalOrganization`), которые
        сами не являются филиалами (т.е. у которых `parent_id` равен `None`).
        Эти организации могут выступать в качестве головных для других. Список
        сортируется по краткому наименованию.
    3.  **Формирование `choices` для поля "Регион"**: Создает список кортежей `(value, label)`
        для поля `form.region.choices`. В начало списка добавляется опция
        "--- Не выбрано ---" со значением `0`.
    4.  **Формирование `choices` для поля "Головная организация"**: Если в переданной
        форме `form` существует поле `parent` (проверяется через `hasattr`),
        аналогичным образом формируется список `choices` для него. В начало
        добавляется опция "--- Нет (Головная организация) ---" со значением `0`.

    Параметры:
        form (FlaskForm): Экземпляр формы (предположительно, `OrganizationForm` или
                          совместимой), содержащей поля `SelectField` с именами
                          `region` и, возможно, `parent`, атрибуты `choices` которых
                          необходимо заполнить.
    """
    # 1. Загрузка регионов:
    # `db.select(Region).order_by(Region.name)` создает запрос на выборку всех регионов,
    # отсортированных по полю `name`.
    # `db.session.execute(...).scalars().all()` выполняет запрос и возвращает список объектов `Region`.
    regions = db.session.execute(db.select(Region).order_by(Region.name)).scalars().all()

    # 2. Загрузка головных организаций:
    # `db.select(EducationalOrganization).filter(EducationalOrganization.parent_id.is_(None))`
    # создает запрос на выборку организаций, у которых поле `parent_id` равно NULL
    # (т.е. они не имеют родительской организации).
    # `.order_by(EducationalOrganization.short_name)` сортирует их по краткому наименованию.
    parents = db.session.execute(
        db.select(EducationalOrganization).filter(EducationalOrganization.parent_id.is_(None)).order_by(EducationalOrganization.short_name)
    ).scalars().all()

    # 3. Формирование `choices` для поля "Регион":
    # `form.region.choices` присваивается список. Первый элемент `(0, '--- Не выбрано ---')`
    # представляет собой опцию по умолчанию, позволяющую пользователю не выбирать конкретный регион.
    # Далее, с помощью генератора списка `[(r.id, r.name) for r in regions]`,
    # для каждого объекта `Region` из списка `regions` создается кортеж `(ID_региона, Название_региона)`,
    # который добавляется в `choices`.
    form.region.choices = [(0, '--- Не выбрано ---')] + [(r.id, r.name) for r in regions]

    # 4. Формирование `choices` для поля "Головная организация" (если оно есть в форме):
    # `hasattr(form, 'parent')` проверяет, есть ли у объекта `form` атрибут (поле) с именем `parent`.
    # Это делается для того, чтобы функция могла работать с формами, где поле `parent`
    # может отсутствовать, не вызывая при этом ошибку.
    if hasattr(form, 'parent'):
        # Аналогично полю `region`, формируется список `choices` для `form.parent.choices`.
        # Опция по умолчанию `(0, '--- Нет (Головная организация) ---')` позволяет указать,
        # что создаваемая/редактируемая организация сама является головной.
        # В качестве метки (label) для выбора родительской организации используется
        # `p.short_name`, если оно заполнено, в противном случае — `p.full_name`.
        form.parent.choices = [(0, '--- Нет (Головная организация) ---')] + \
                              [(p.id, p.short_name or p.full_name) for p in parents]


# Маршрут для страницы добавления новой образовательной организации.
# Доступен по URL `/organization/add`.
# `methods=['GET', 'POST']` указывает, что этот маршрут может обрабатывать
# как GET-запросы (когда пользователь просто открывает страницу для просмотра формы),
# так и POST-запросы (когда пользователь отправляет заполненную форму на сервер).
# Декоратор `@login_required` из Flask-Login гарантирует, что доступ к этому маршруту
# будет разрешен только тем пользователям, которые уже вошли в систему (аутентифицированы).
# Попытка доступа неаутентифицированного пользователя приведет к перенаправлению на страницу входа.
@main_bp.route('/organization/add', methods=['GET', 'POST'])
@login_required
def add_organization():
    """
    Обработчик HTTP-запросов для страницы добавления новой образовательной организации.

    Эта функция управляет логикой отображения формы для добавления организации
    и обработкой данных, отправленных пользователем через эту форму.

    При GET-запросе:
    1.  Создается пустой экземпляр формы `OrganizationForm`.
    2.  Вызывается вспомогательная функция `_populate_organization_form_choices()`
        для динамического заполнения выпадающих списков (регионы, головные организации)
        в созданном экземпляре формы.
    3.  Отображается HTML-шаблон `organization_form.html`. В шаблон передаются:
        -   `title`: Заголовок для страницы ("Добавить организацию").
        -   `form`: Экземпляр формы (пустой, но с заполненными `choices`).

    При POST-запросе (когда пользователь заполнил и отправил форму):
    1.  Создается экземпляр формы `OrganizationForm`. Flask-WTF автоматически
        заполнит поля этой формы данными из `request.form` (данные, отправленные
        в теле POST-запроса).
    2.  Вызывается метод `form.validate_on_submit()`. Этот метод делает две вещи:
        a.  Проверяет, был ли запрос сделан методом POST.
        b.  Если да, то вызывает метод `form.validate()`, который запускает все
            валидаторы, определенные для полей формы (включая стандартные, такие как
            `DataRequired`, `Length`, и пользовательские, такие как `validate_ogrn`).
    3.  Если `form.validate_on_submit()` возвращает `True` (т.е. форма отправлена
        методом POST и все данные в ней валидны):
        a.  Создается новый объект модели `EducationalOrganization`.
        b.  Атрибуты этого объекта (соответствующие столбцам в таблице БД)
            заполняются данными из соответствующих полей формы (например,
            `new_org.full_name = form.full_name.data`). Значения строковых полей
            рекомендуется очищать от лишних пробелов с помощью `.strip()`.
            Для внешних ключей (`region_id`, `parent_id`) проверяется, было ли
            выбрано значение, отличное от "пустой" опции (которая имеет значение 0),
            и если да, то используется ID выбранной записи, иначе устанавливается `None`.
        c.  Новый объект организации добавляется в сессию SQLAlchemy с помощью
            `db.session.add(new_org)`. На этом этапе изменения еще не записаны в БД.
        d.  Выполняется попытка зафиксировать изменения в базе данных с помощью
            `db.session.commit()`. Это выполнит SQL INSERT-запрос.
        e.  Если сохранение в БД прошло успешно (`commit()` не вызвал исключений):
            -   Отображается flash-сообщение пользователю об успешном добавлении организации.
            -   Пользователь перенаправляется на страницу реестра организаций
                (URL генерируется с помощью `url_for('.show_registry')`).
        f.  Если при сохранении в БД произошла ошибка (например, `IntegrityError` из-за
            нарушения уникального ограничения, которое не было поймано валидатором формы,
            или любая другая ошибка СУБД):
            -   Транзакция откатывается с помощью `db.session.rollback()`, чтобы
                база данных осталась в согласованном состоянии.
            -   Отображается flash-сообщение пользователю об ошибке.
            -   (Обычно после этого происходит повторное отображение формы с ошибками,
                что происходит автоматически, так как `redirect` не выполняется).
    4.  Если `form.validate_on_submit()` возвращает `False` (т.е. запрос был GET,
        или это был POST-запрос, но форма не прошла валидацию):
        -   Отображается HTML-шаблон `organization_form.html`.
            -   Если это был GET-запрос, форма будет пустой (но с заполненными `choices`).
            -   Если это был POST-запрос с ошибками валидации, объект `form` будет
                содержать эти ошибки (в `form.errors`), а также данные, введенные
                пользователем. Шаблон может использовать эту информацию для отображения
                сообщений об ошибках рядом с соответствующими полями и для сохранения
                введенных пользователем корректных данных.

    Возвращает:
        str | werkzeug.wrappers.Response: Строка с HTML-кодом страницы (с формой для
                                          добавления организации) или HTTP-ответ
                                          с перенаправлением (после успешного добавления).
    """
    # Здесь можно было бы добавить дополнительную проверку прав доступа, например,
    # убедиться, что текущий пользователь (`current_user`) имеет соответствующую роль
    # или разрешение для добавления организаций.
    # Пример:
    # if not current_user.is_administrator(): # Предполагая, что у User есть такой метод/свойство
    #     flash('У вас нет прав для выполнения этого действия.', 'danger')
    #     abort(403) # Возвращает HTTP ошибку 403 Forbidden (Доступ запрещен)

    # Создаем экземпляр формы `OrganizationForm`.
    # Если метод запроса POST, Flask-WTF автоматически попытается заполнить
    # форму данными из `request.form`.
    form = OrganizationForm()
    # Динамически заполняем поля `SelectField` (такие как регион, головная организация)
    # актуальными данными из базы данных, вызывая нашу вспомогательную функцию.
    _populate_organization_form_choices(form)

    # `form.validate_on_submit()` — это удобный метод Flask-WTF.
    # Он возвращает `True` только в том случае, если:
    # 1. Запрос был сделан методом POST.
    # 2. Все данные, отправленные в форме, успешно прошли все валидаторы,
    #    определенные для полей этой формы (включая стандартные и пользовательские).
    if form.validate_on_submit():
        # Если форма была отправлена и все данные в ней корректны:
        # Создаем новый экземпляр модели `EducationalOrganization`.
        # Заполняем его атрибуты данными из соответствующих полей формы.
        # Используем `.data` для доступа к значению поля формы.
        # Для строковых полей рекомендуется использовать `.strip()` для удаления
        # случайных пробелов в начале или конце строки.
        new_org = EducationalOrganization(
            full_name=form.full_name.data.strip(),
            short_name=form.short_name.data.strip() if form.short_name.data else None, # Если поле не заполнено, short_name.data будет пустой строкой или None.
            ogrn=form.ogrn.data.strip(),
            inn=form.inn.data.strip() if form.inn.data else None,
            address=form.address.data.strip() if form.address.data else None,
            # Для полей `SelectField`, которые представляют внешние ключи (например, `region_id`),
            # мы проверяем, было ли выбрано значение, отличное от "пустой" опции (которая имеет значение 0).
            # Если выбрано конкретное значение (ID > 0), используем его. Иначе устанавливаем `None`,
            # что соответствует отсутствию связи в базе данных (если столбец допускает NULL).
            region_id=form.region.data if form.region.data and form.region.data != 0 else None
        )
        # Обрабатываем поле `parent_id` (головная организация) аналогичным образом,
        # но только если поле `parent` существует в экземпляре формы.
        if hasattr(form, 'parent'):
            new_org.parent_id = form.parent.data if form.parent.data and form.parent.data != 0 else None

        # Добавляем созданный объект `new_org` в сессию SQLAlchemy.
        # Это еще не записывает данные в базу, а только помечает объект для последующей вставки.
        db.session.add(new_org)
        try:
            # Пытаемся зафиксировать все изменения, сделанные в текущей сессии SQLAlchemy
            # (в данном случае, добавление нового объекта `new_org`), в базе данных.
            # Это приведет к выполнению SQL INSERT-запроса.
            db.session.commit()
            # Если `commit()` прошел успешно (т.е. не было вызвано исключений),
            # показываем пользователю flash-сообщение об успехе.
            # 'success' — это категория сообщения, которая может использоваться в шаблоне для стилизации
            # (например, зеленый цвет для сообщений об успехе).
            flash('Организация успешно добавлена!', 'success')
            # Перенаправляем пользователя на страницу реестра организаций.
            # `url_for('.show_registry')` генерирует URL для функции `show_registry` этого Blueprint'а.
            return redirect(url_for('.show_registry'))
        except Exception as e:
            # Если во время выполнения `db.session.commit()` произошла ошибка
            # (например, `sqlalchemy.exc.IntegrityError` из-за нарушения уникального
            # ограничения в базе данных, которое не было поймано валидатором формы,
            # или любая другая ошибка, связанная с базой данных),
            # необходимо откатить текущую транзакцию.
            db.session.rollback()
            # Показываем пользователю flash-сообщение об ошибке.
            # В реальном приложении здесь также крайне рекомендуется логировать полную информацию
            # об ошибке `e` (например, с помощью стандартного модуля `logging` Python)
            # для последующего анализа и отладки разработчиками.
            flash(f'Ошибка при добавлении организации: {e}', 'error')
            # После отката и показа сообщения, выполнение продолжится, и будет
            # отображен шаблон с формой (см. `return render_template` ниже),
            # что позволит пользователю исправить ошибки, если они были связаны с вводом.

    # Если метод запроса был GET, или если `form.validate_on_submit()` вернул `False`
    # (т.е. форма была отправлена методом POST, но не прошла валидацию),
    # то отображаем HTML-шаблон `organization_form.html`.
    #   - `title='Добавить организацию'`: Передаем заголовок для страницы.
    #   - `form=form`: Передаем экземпляр формы.
    #     - Если это был GET-запрос, форма будет пустой (но с заполненными `choices`
    #       благодаря `_populate_organization_form_choices`).
    #     - Если это был POST-запрос с ошибками валидации, объект `form` будет
    #       содержать эти ошибки (доступные через `form.errors` или `form.<fieldname>.errors`),
    #       а также данные, введенные пользователем (в `form.<fieldname>.data`).
    #       Шаблон может использовать эту информацию для отображения сообщений об ошибках
    #       рядом с соответствующими полями и для сохранения введенных пользователем
    #       корректных данных в полях формы.
    return render_template('organization_form.html', title='Добавить организацию', form=form)


# Маршрут для страницы редактирования существующей образовательной организации.
# URL-адрес этого маршрута имеет вид `/organization/<int:org_id>/edit`,
# где `<int:org_id>` — это динамическая часть URL, представляющая целочисленный
# идентификатор (ID) организации, которую нужно отредактировать. Flask автоматически
# преобразует эту часть URL в аргумент `org_id` функции `edit_organization`.
# `methods=['GET', 'POST']` указывает, что маршрут обрабатывает GET-запросы (для
# отображения формы с текущими данными организации) и POST-запросы (когда пользователь
# отправляет измененные данные для сохранения).
# `@login_required` требует, чтобы пользователь был аутентифицирован.
@main_bp.route('/organization/<int:org_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_organization(org_id):
    """
    Обработчик HTTP-запросов для страницы редактирования существующей образовательной организации.

    Эта функция позволяет пользователям изменять данные уже существующей в базе
    образовательной организации.

    Параметры:
        org_id (int): Идентификатор (первичный ключ) образовательной организации,
                      запись которой необходимо отредактировать. Это значение
                      извлекается из URL-адреса.

    При GET-запросе:
    1.  Из базы данных загружается объект `EducationalOrganization` с указанным `org_id`.
        Если организация с таким ID не найдена, автоматически возвращается ошибка 404 Not Found
        (благодаря использованию `db.get_or_404()`).
    2.  Создается экземпляр формы `OrganizationForm`. В конструктор формы передаются:
        -   `original_ogrn=organization.ogrn`: Текущее значение ОГРН организации.
            Это необходимо для пользовательского валидатора `validate_ogrn` в форме,
            чтобы он мог корректно проверить уникальность ОГРН (проверка не нужна,
            если ОГРН не изменился).
        -   `obj=organization`: Сам объект организации. WTForms использует этот объект
            для автоматического заполнения полей формы текущими значениями атрибутов
            организации (например, `form.full_name.data` будет равно `organization.full_name`).
    3.  Вызывается вспомогательная функция `_populate_organization_form_choices()`
        для заполнения выпадающих списков (регионы, головные организации) в форме.
    4.  Отображается HTML-шаблон `organization_form.html`. В шаблон передаются:
        -   `title`: Заголовок для страницы ("Редактировать организацию").
        -   `form`: Экземпляр формы, заполненный данными редактируемой организации.
        -   `organization`: Сам объект организации (может быть полезен в шаблоне
            для отображения дополнительной информации, не редактируемой через форму).

    При POST-запросе (когда пользователь отправил измененную форму):
    1.  Создается экземпляр формы `OrganizationForm`, автоматически заполненный
        данными из `request.form`. `original_ogrn` также передается.
    2.  Вызывается `form.validate_on_submit()`.
    3.  Если форма валидна:
        a.  Атрибуты существующего объекта `organization` (загруженного ранее из БД)
            обновляются данными из соответствующих полей формы.
            Рекомендуется использовать `.strip()` для строковых полей.
            Для внешних ключей (`region_id`, `parent_id`) значение 0 из формы
            интерпретируется как `None` (отсутствие связи).
        b.  Выполняется попытка зафиксировать изменения в базе данных (`db.session.commit()`).
            Это выполнит SQL UPDATE-запрос.
        c.  Если сохранение успешно:
            -   Отображается flash-сообщение об успехе.
            -   Пользователь перенаправляется на страницу реестра.
        d.  Если при сохранении произошла ошибка:
            -   Транзакция откатывается (`db.session.rollback()`).
            -   Отображается flash-сообщение об ошибке.
    4.  Если форма невалидна (при POST-запросе) или это GET-запрос:
        -   Отображается шаблон `organization_form.html` с формой (и ошибками, если были).

    Возвращает:
        str | werkzeug.wrappers.Response: HTML-страница с формой редактирования или
                                          HTTP-перенаправление после успешного обновления.
    """
    # Здесь также можно добавить проверку прав доступа, аналогично `add_organization`.
    # if not current_user.can(Permission.EDIT_ORGANIZATIONS):
    #     flash('У вас нет прав для редактирования организаций.', 'danger')
    #     abort(403)

    # Загружаем объект `EducationalOrganization` из базы данных по его `id`.
    # `db.get_or_404(ModelClass, primary_key_value)` — это удобный метод Flask-SQLAlchemy,
    # который пытается найти запись по первичному ключу. Если запись не найдена,
    # он автоматически вызывает `abort(404)`, что приводит к отображению страницы
    # ошибки "404 Not Found".
    organization = db.get_or_404(EducationalOrganization, org_id)

    # Создаем экземпляр формы `OrganizationForm`.
    #   - `original_ogrn=organization.ogrn`: Передаем текущее (оригинальное) значение ОГРН
    #     редактируемой организации. Это используется в пользовательском валидаторе `validate_ogrn`
    #     внутри класса `OrganizationForm`, чтобы разрешить сохранение формы, если ОГРН
    #     не изменился (иначе проверка уникальности сработает на текущее значение).
    #   - `obj=organization`: Передаем сам объект `organization` в конструктор формы.
    #     WTForms использует этот объект для автоматического заполнения полей формы
    #     текущими значениями атрибутов объекта `organization`. Это работает, если
    #     имена полей формы совпадают с именами атрибутов модели.
    #     Например, `form.full_name.data` будет инициализировано значением `organization.full_name`.
    form = OrganizationForm(original_ogrn=organization.ogrn, obj=organization)
    # Динамически заполняем `choices` для полей `SelectField` в форме.
    _populate_organization_form_choices(form)

    # Если форма была отправлена (POST) и успешно прошла валидацию.
    if form.validate_on_submit():
        # Обновляем атрибуты существующего объекта `organization` данными из формы.
        # SQLAlchemy отслеживает изменения в объектах, находящихся в сессии,
        # и при вызове `db.session.commit()` сгенерирует соответствующие SQL UPDATE-запросы.
        organization.full_name = form.full_name.data.strip()
        organization.short_name = form.short_name.data.strip() if form.short_name.data else None
        organization.ogrn = form.ogrn.data.strip()
        organization.inn = form.inn.data.strip() if form.inn.data else None
        organization.address = form.address.data.strip() if form.address.data else None
        organization.region_id = form.region.data if form.region.data and form.region.data != 0 else None
        if hasattr(form, 'parent'): # Обновляем parent_id только если поле parent есть в форме
            organization.parent_id = form.parent.data if form.parent.data and form.parent.data != 0 else None
        
        try:
            # Фиксируем изменения в базе данных.
            db.session.commit()
            flash('Данные организации успешно обновлены!', 'success')
            # Перенаправляем пользователя на страницу реестра после успешного обновления.
            return redirect(url_for('.show_registry'))
        except Exception as e:
            # В случае ошибки при сохранении, откатываем транзакцию.
            db.session.rollback()
            flash(f'Ошибка при обновлении организации: {e}', 'error')
            # Логирование ошибки `e` здесь также было бы полезно.

    # Если запрос был GET, или если форма была отправлена (POST) но не прошла валидацию,
    # отображаем шаблон `organization_form.html`.
    #   - `title`: Заголовок страницы.
    #   - `form`: Экземпляр формы (будет содержать текущие данные организации при GET,
    #     или введенные пользователем данные и ошибки валидации при POST с ошибками).
    #   - `organization`: Сам объект организации, передается в шаблон, чтобы можно было
    #     отобразить какую-либо нередактируемую информацию (например, ID или дату создания).
    return render_template('organization_form.html', title='Редактировать организацию', form=form, organization=organization)

    # Если форма не отправлена или есть ошибки — показываем страницу с формой.
    return render_template('organization_form.html', title='Редактировать организацию', form=form, organization=organization)


# Маршрут для удаления образовательной организации.
# URL-адрес: `/organization/<int:org_id>/delete`.
#   - `<int:org_id>`: Динамическая часть URL, представляющая ID организации для удаления.
# `methods=['POST']`: Этот маршрут принимает **только** POST-запросы.
#   Это важное соображение безопасности: операции, изменяющие состояние данных (как удаление),
#   не должны быть доступны через GET-запросы, так как GET-запросы могут быть легко
#   инициированы (например, поисковыми роботами, простым переходом по ссылке,
#   вредоносными тегами `<img>` на других сайтах), что может привести к случайному
#   или злонамеренному удалению данных. POST-запросы обычно требуют явного действия
#   пользователя (например, нажатия кнопки в форме).
# `@login_required`: Требует аутентификации пользователя.
@main_bp.route('/organization/<int:org_id>/delete', methods=['POST'])
@login_required
def delete_organization(org_id):
    """
    Обработчик HTTP POST-запросов для удаления существующей образовательной организации.

    Эта функция выполняет следующие действия:
    1.  Загружает объект `EducationalOrganization` из базы данных по `org_id`,
        переданному в URL. Если организация не найдена, возвращается ошибка 404.
    2.  (Рекомендация) Выполняет проверку прав доступа текущего пользователя:
        имеет ли он разрешение на удаление организаций.
    3.  (Рекомендация) Выполняет проверку на наличие связанных данных (зависимостей),
        которые могут препятствовать удалению или требуют каскадного удаления
        (например, связанные образовательные программы). Если такие зависимости есть
        и не настроено автоматическое каскадное удаление на уровне БД или ORM,
        удаление может завершиться ошибкой или оставить "осиротевшие" записи.
    4.  Удаляет найденный объект организации из сессии SQLAlchemy (`db.session.delete()`).
    5.  Пытается зафиксировать изменения в базе данных (`db.session.commit()`), что
        приведет к выполнению SQL DELETE-запроса.
    6.  В случае успеха отображает flash-сообщение об успешном удалении.
    7.  В случае ошибки при удалении (например, из-за нарушения ограничений внешнего ключа,
        если не учтены зависимости) откатывает транзакцию и отображает flash-сообщение
        об ошибке. Также рекомендуется логировать такие ошибки.
    8.  В любом случае (успех или ошибка) перенаправляет пользователя обратно
        на страницу реестра организаций.

    Параметры:
        org_id (int): Идентификатор (первичный ключ) образовательной организации,
                      которую необходимо удалить.

    Возвращает:
        werkzeug.wrappers.Response: HTTP-ответ с перенаправлением на страницу реестра.
    """
    # Здесь также крайне рекомендуется добавить проверку прав доступа.
    # Например, только пользователи с ролью "администратор" могут удалять организации.
    # if not current_user.is_administrator(): # Пример проверки
    #     flash('У вас нет прав для удаления организаций.', 'danger')
    #     abort(403) # HTTP 403 Forbidden

    # Загружаем организацию из БД. Если не найдена, db.get_or_404 вернет 404 ошибку.
    organization = db.get_or_404(EducationalOrganization, org_id)

    try:
        # Перед удалением важно рассмотреть зависимости:
        # - Если у `EducationalOrganization` есть связанные `EducationalProgram`
        #   и в `db.relationship` для `programs` в модели `EducationalOrganization`
        #   настроено `cascade="all, delete-orphan"` или аналогичное, то связанные
        #   программы будут удалены автоматически.
        # - Если каскадное удаление не настроено, а внешний ключ в `EducationalProgram`
        #   (ссылающийся на организацию) не допускает NULL и не имеет опции ON DELETE SET NULL/CASCADE
        #   на уровне БД, то попытка удалить организацию, у которой есть программы,
        #   приведет к ошибке `IntegrityError`.
        # - Поэтому, если каскадное удаление нежелательно или не настроено,
        #   здесь может потребоваться явная проверка:
        #   `if organization.programs.count() > 0:`
        #   `    flash('Невозможно удалить организацию, так как у нее есть связанные программы.', 'danger')`
        #   `    return redirect(url_for('.show_registry'))`

        # Помечаем объект организации для удаления из сессии SQLAlchemy.
        db.session.delete(organization)
        # Фиксируем изменения в базе данных (выполняется SQL DELETE).
        db.session.commit()
        # Сообщаем пользователю об успехе. Используем f-строку для включения
        # имени удаленной организации в сообщение, если это полезно.
        flash(f'Организация "{organization.short_name or organization.full_name}" успешно удалена.', 'success')
    except Exception as e:
        # Если во время `commit()` произошла ошибка.
        db.session.rollback() # Откатываем транзакцию.
        # Сообщаем пользователю об ошибке.
        flash(f'Ошибка при удалении организации: {e}', 'error')
        # Важно логировать такие ошибки для администратора системы.
        # current_app.logger.error(f"Error deleting organization {org_id}: {e}")

    # Вне зависимости от результата операции удаления (успех или ошибка с откатом),
    # перенаправляем пользователя обратно на страницу реестра.
    # Если была ошибка, пользователь увидит flash-сообщение об ошибке на странице реестра.
    return redirect(url_for('.show_registry'))

# TODO: Добавить CRUD для других моделей (программы, специальности и т.д.)
# Этот комментарий-напоминание указывает на то, что в будущем может потребоваться
# реализовать аналогичные CRUD-операции (Create, Read, Update, Delete)
# для других сущностей системы, таких как образовательные программы, специальности,
# укрупненные группы специальностей и т.д., если для них предполагается
# административный интерфейс управления.

# --- Маршруты для администрирования регионов ---
# Следующий блок кода определяет маршруты, предназначенные для управления
# справочником регионов. Предполагается, что эти маршруты будут частью
# административной панели сайта.
# Важно: Все эти маршруты помечены `@login_required`, но для реального
# административного функционала этого недостаточно. Необходимо добавить
# проверку роли пользователя (например, `if not current_user.is_admin(): abort(403)`),
# чтобы только администраторы могли получить доступ к этим операциям.
# Комментарии `TODO: Replace with admin role check` указывают на это.

# Маршрут для отображения списка всех регионов в административной панели.
# Доступен по URL `/admin/regions`.
@main_bp.route('/admin/regions')
@login_required # НЕОБХОДИМА ПРОВЕРКА РОЛИ АДМИНИСТРАТОРА!
def admin_regions_list():
    """
    Обработчик для отображения списка регионов в административной панели.

    Загружает все регионы из базы данных, сортирует их по названию и
    передает в HTML-шаблон `admin/regions_list.html` для отображения.
    Этот шаблон должен содержать таблицу со списком регионов и, возможно,
    ссылки для добавления нового региона, редактирования и удаления существующих.

    Возвращает:
        str: HTML-страница со списком регионов.
    """
    # TODO: Заменить простой `@login_required` на полноценную проверку роли администратора.
    # Пример:
    # if not getattr(current_user, 'is_admin', False): # Проверка, есть ли у пользователя флаг is_admin
    #     flash('Доступ запрещен. Требуются права администратора.', 'danger')
    #     abort(403)

    # Загружаем все объекты `Region` из базы данных, отсортированные по полю `name`.
    regions = db.session.execute(db.select(Region).order_by(Region.name)).scalars().all()
    # Отображаем шаблон, передавая в него список регионов и заголовок страницы.
    return render_template('admin/regions_list.html', regions=regions, title="Управление регионами")

# Маршрут для добавления нового региона.
# Доступен по URL `/admin/regions/add`. Обрабатывает GET и POST запросы.
@main_bp.route('/admin/regions/add', methods=['GET', 'POST'])
@login_required # НЕОБХОДИМА ПРОВЕРКА РОЛИ АДМИНИСТРАТОРА!
def admin_region_add():
    """
    Обработчик для добавления нового региона через административную панель.

    При GET-запросе отображает форму `RegionForm` для ввода названия нового региона.
    При POST-запросе (после отправки формы):
    - Валидирует данные формы.
    - Если форма валидна, создает новый объект `Region`, сохраняет его в базе данных.
    - Отображает flash-сообщение об успехе или ошибке.
    - Перенаправляет на страницу списка регионов.
    Если форма невалидна, повторно отображает форму с ошибками.

    Возвращает:
        str | werkzeug.wrappers.Response: HTML-страница с формой или перенаправление.
    """
    # TODO: Заменить на проверку роли администратора.
    form = RegionForm() # Создаем экземпляр формы для региона.
    if form.validate_on_submit():
        # Если форма отправлена и валидна, получаем название региона из формы,
        # удаляя лишние пробелы по краям с помощью `.strip()`.
        region_name = form.name.data.strip()
        new_region = Region(name=region_name)
        db.session.add(new_region) # Добавляем новый регион в сессию.
        try:
            db.session.commit() # Сохраняем в БД.
            flash(f'Регион "{new_region.name}" успешно добавлен.', 'success')
            return redirect(url_for('.admin_regions_list')) # Перенаправляем на список регионов.
        except Exception as e: # Ловим общие исключения, но лучше конкретизировать (например, IntegrityError)
            db.session.rollback() # Откатываем транзакцию в случае ошибки.
            # Проверяем, не является ли ошибка ошибкой уникальности (если валидатор формы ее не поймал)
            # Это очень упрощенная проверка, в реальности может потребоваться более точный анализ типа исключения.
            if "UNIQUE constraint failed" in str(e).upper() or "duplicate key value violates unique constraint" in str(e).lower():
                 flash(f'Ошибка: Регион с названием "{region_name}" уже существует.', 'error')
            else:
                 flash(f'Ошибка при добавлении региона: {e}', 'error')
            # Логирование ошибки e здесь также было бы полезно.
    # Если GET-запрос или форма невалидна, отображаем шаблон с формой.
    return render_template('admin/region_form.html', form=form, title='Добавить регион')

# Маршрут для редактирования существующего региона.
# Доступен по URL `/admin/regions/<int:region_id>/edit`.
@main_bp.route('/admin/regions/<int:region_id>/edit', methods=['GET', 'POST'])
@login_required # НЕОБХОДИМА ПРОВЕРКА РОЛИ АДМИНИСТРАТОРА!
def admin_region_edit(region_id):
    """
    Обработчик для редактирования существующего региона через административную панель.

    Параметры:
        region_id (int): ID региона для редактирования.

    При GET-запросе загружает регион, инициализирует форму `RegionForm` его данными
    и отображает шаблон с формой.
    При POST-запросе валидирует данные, обновляет регион в БД, обрабатывает ошибки
    и перенаправляет на список регионов.

    Возвращает:
        str | werkzeug.wrappers.Response: HTML-страница с формой или перенаправление.
    """
    # TODO: Заменить на проверку роли администратора.
    region = db.get_or_404(Region, region_id) # Загружаем регион или получаем 404.
    # Создаем форму, передавая original_name для валидатора уникальности
    # и obj для автоматического заполнения полей формы текущими данными региона.
    form = RegionForm(original_name=region.name, obj=region)
    if form.validate_on_submit():
        region.name = form.name.data.strip() # Обновляем название региона.
        try:
            db.session.commit() # Сохраняем изменения.
            flash(f'Регион "{region.name}" успешно обновлен.', 'success')
            return redirect(url_for('.admin_regions_list'))
        except Exception as e:
            db.session.rollback()
            if "UNIQUE constraint failed" in str(e).upper() or "duplicate key value violates unique constraint" in str(e).lower():
                 flash(f'Ошибка: Регион с названием "{region.name}" уже существует (возможно, вы пытаетесь переименовать в уже существующее название).', 'error')
            else:
                 flash(f'Ошибка при обновлении региона: {e}', 'error')
    # Отображаем шаблон с формой (при GET или если POST невалиден).
    return render_template('admin/region_form.html', form=form, title='Редактировать регион', region=region)

# Маршрут для удаления региона.
# Доступен по URL `/admin/regions/<int:region_id>/delete`. Только POST-запросы.
@main_bp.route('/admin/regions/<int:region_id>/delete', methods=['POST'])
@login_required # НЕОБХОДИМА ПРОВЕРКА РОЛИ АДМИНИСТРАТОРА!
def admin_region_delete(region_id):
    """
    Обработчик для удаления региона через административную панель.

    Параметры:
        region_id (int): ID региона для удаления.

    Загружает регион, проверяет зависимости (наличие организаций в этом регионе),
    удаляет регион из БД, обрабатывает ошибки и перенаправляет на список регионов.

    Возвращает:
        werkzeug.wrappers.Response: Перенаправление на список регионов.
    """
    # TODO: Заменить на проверку роли администратора.
    region = db.get_or_404(Region, region_id) # Загружаем регион.
    try:
        # Важная проверка: нельзя удалять регион, если в нем есть организации.
        # `region.organizations` - это relationship. `.count()` выполнит запрос COUNT(*).
        # Предполагается, что `lazy='dynamic'` для `Region.organizations` или используется
        # другой способ подсчета без загрузки всех объектов. Если `lazy='select'` (по умолчанию),
        # то `len(region.organizations)` загрузит все организации, что может быть неэффективно.
        # `region.organizations.count()` (если `lazy='dynamic'`) или
        # `db.session.query(EducationalOrganization).filter_by(region_id=region.id).count()`
        # являются более эффективными способами.
        # В текущей модели Region.organizations - lazy='dynamic', так что .count() подойдет.
        if region.organizations.count() > 0:
            flash(f'Невозможно удалить регион "{region.name}", так как он используется образовательными организациями. '
                  'Сначала измените регион у этих организаций или удалите их.', 'danger')
            return redirect(url_for('.admin_regions_list'))

        db.session.delete(region) # Удаляем регион из сессии.
        db.session.commit() # Фиксируем удаление в БД.
        flash(f'Регион "{region.name}" успешно удален.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при удалении региона: {e}', 'error')
        # Логирование ошибки.
    return redirect(url_for('.admin_regions_list')) # Перенаправляем на список регионов.
